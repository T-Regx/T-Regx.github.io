(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{178:function(e,n,t){"use strict";t.d(n,"a",(function(){return d})),t.d(n,"b",(function(){return g}));var a=t(0),o=t.n(a),i=t(182),r=t(183),p=t(184),c=t(4),l=t(179),s=t(48),m=t.n(s),u=function(e){function n(){return e.apply(this,arguments)||this}return Object(c.a)(n,e),n.prototype.render=function(){return o.a.createElement("div",{className:m.a.code},o.a.createElement(l.a,{className:"language-"+this.language},this.code))},Object(p.a)(n,[{key:"language",get:function(){return this.props.language||"php"}},{key:"code",get:function(){var e=this.props.children;if("string"==typeof e)return e;if(Array.isArray(e)&&e.every((function(e){return"string"==typeof e})))return e.join("");throw console.log(this.props.children),"Unexpected child of <Code>"}}]),n}(o.a.Component),d=function(e){var n=e.tregx,t=e.php,a=[n?{label:"T-Regx",value:"t-regx"}:{},t?{label:"PHP",value:"php"}:{}].filter((function(e){return e.value}));return o.a.createElement(i.a,{defaultValue:"t-regx",values:a},n&&o.a.createElement(r.a,{value:"t-regx"},o.a.createElement(u,null,n)),t&&o.a.createElement(r.a,{value:"php"},o.a.createElement(u,null,t)))},b=t(49),h=t.n(b),g=function(e){var n=e.text,t=e.children;return o.a.createElement("div",{className:h.a.result},o.a.createElement(u,{language:n?"text":"php"},t))}},98:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return p})),t.d(n,"metadata",(function(){return c})),t.d(n,"rightToc",(function(){return l})),t.d(n,"default",(function(){return m}));var a=t(2),o=t(6),i=(t(0),t(177)),r=t(178),p={id:"replace-by-map",title:"Replace by map"},c={unversionedId:"replace-by-map",id:"replace-by-map",isDocsHomePage:!1,title:"Replace by map",description:"There are cases when you have to use more than one replacement (so with() won't work),",source:"@site/../docs/replace-by-map.mdx",slug:"/replace-by-map",permalink:"/docs/replace-by-map",version:"current",lastUpdatedAt:1604757655,sidebar:"docs",previous:{title:"Replace by group",permalink:"/docs/replace-by-group"},next:{title:"Handling user input",permalink:"/docs/handling-user-input"}},l=[{value:"Standard map",id:"standard-map",children:[{value:"Superfluous matches",id:"superfluous-matches",children:[]},{value:"Ignored replacements",id:"ignored-replacements",children:[]}]},{value:"Groups",id:"groups",children:[]}],s={rightToc:l};function m(e){var n=e.components,t=Object(o.a)(e,["components"]);return Object(i.b)("wrapper",Object(a.a)({},s,t,{components:n,mdxType:"MDXLayout"}),Object(i.b)("p",null,"There are cases when you have to use more than one replacement (so ",Object(i.b)("inlineCode",{parentName:"p"},"with()")," won't work),\nbut you also don't need ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/match-details"}),Object(i.b)("inlineCode",{parentName:"a"},"Match"))," details or\nany replacement logic, really (so ",Object(i.b)("inlineCode",{parentName:"p"},"callback()")," is a little too much)."),Object(i.b)("p",null,"Replacing by a map is an acceptable compromise, which allows T-Regx to save a little performance\noverhead, by not creating ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/match-details"}),Object(i.b)("inlineCode",{parentName:"a"},"Match"))," object, as well as making your code a\nlittle more concise."),Object(i.b)("h2",{id:"standard-map"},"Standard map"),Object(i.b)("p",null,"You can use ",Object(i.b)("inlineCode",{parentName:"p"},"replace()->all()->by()->map()")," to replace a matched, predefined value (",Object(i.b)("inlineCode",{parentName:"p"},'"mp3"'),", ",Object(i.b)("inlineCode",{parentName:"p"},'"mp4"')," or ",Object(i.b)("inlineCode",{parentName:"p"},'"gif"'),")\nby its direct counter-part (",Object(i.b)("inlineCode",{parentName:"p"},"'Audio file'"),", ",Object(i.b)("inlineCode",{parentName:"p"},"'Video file'"),", ",Object(i.b)("inlineCode",{parentName:"p"},"'Animation'"),"):"),Object(i.b)(r.a,{tregx:"$message = 'My words: \"mp3\", \"mp4\", \"gif\"';\n\npattern('\\b\\w{3}\\b')->replace($message)->all()->by()->map([\n    'mp3' => 'Audio file',\n    'mp4' => 'Video file',\n    'gif' => 'Animation'\n]);",php:"$message = 'My words: \"mp3\", \"mp4\", \"gif\"';\n\npreg::replace_callback('/\\b\\w{3}\\b/', function ($match) {\n    $map = [\n        'mp3' => 'Audio file',\n        'mp4' => 'Video file',\n        'gif' => 'Animation'\n    ];\n    if (!array_key_exists($match[0], $map)) {\n        throw new MissingReplacementKeyException();\n    }\n    $result = $map[$match[0]];\n    if (!is_string($result)) {\n        throw new InvalidArgumentException();\n    }\n    return $result;\n}, $message);",mdxType:"CodeTabs"}),Object(i.b)(r.b,{text:!0,mdxType:"Result"},'My words: "Audio file", "Video file", "Animation"'),Object(i.b)("p",null,"Here, we used ",Object(i.b)("inlineCode",{parentName:"p"},"replace()->all()")," as an example, but of course ",Object(i.b)("inlineCode",{parentName:"p"},"replace()->first()")," and\n",Object(i.b)("inlineCode",{parentName:"p"},"replace()->only(int)")," could be used and would replace only the first, or the first few matches."),Object(i.b)("h3",{id:"superfluous-matches"},"Superfluous matches"),Object(i.b)("p",null,"Normally, had you matched a string that's not present in your map, a ",Object(i.b)("inlineCode",{parentName:"p"},"MissingReplacementKeyException")," would be thrown:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-php"}),"$message = 'My words: \"mp3\", \"mp4\", \"xxx\"';\n\npattern('\\w{3}')->replace($message)->all()->by()->map([\n   'mp3'  => 'Audio file',\n   'mp4'  => 'Video file',\n   'gif'  => 'Animation',\n   'xxx'  => 'Unknown'\n]);\n")),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"MissingReplacementKeyException")," is a safe-guard, since ",Object(i.b)("inlineCode",{parentName:"p"},"map()")," is supposed to be only used with a predefined\nset of expected matches, and if a different string is matched (like ",Object(i.b)("inlineCode",{parentName:"p"},'"xxx"'),"), that's a heads up\nthat perhaps something went wrong. Either the map was incomplete, or the pattern allowed some unexpected values."),Object(i.b)("h3",{id:"ignored-replacements"},"Ignored replacements"),Object(i.b)("p",null,"On the other hand, if you want to ignore unexpected values - use ",Object(i.b)("inlineCode",{parentName:"p"},"mapIfExists()"),"."),Object(i.b)("p",null,"With ",Object(i.b)("inlineCode",{parentName:"p"},"mapIfExists()"),", superfluous occurrences are left unchanged:"),Object(i.b)(r.a,{tregx:"$message = \"Extensions: mp3, mp4, jpg, jpeg, png, gif\";\n\npattern('\\b\\w{3,4}\\b')->replace($message)->all()->by()->mapIfExists([\n   'mp3' => 'Audio',\n   'gif' => 'Animation'\n]);",php:"$message = \"Extensions: mp3, mp4, jpg, jpeg, png, gif\";\n\npreg::replace_callback('/\\b\\w{3}\\b/', function ($match) {\n    $map = [\n        'mp3' => 'Audio',\n        'gif' => 'Animation'\n    ];\n    if (!array_key_exists($match[0], $map)) {\n        return $match[0];\n    }\n    $result = $map[$match[0]];\n    if (!is_string($result)) {\n        throw new InvalidArgumentException();\n    }\n    return $result;\n}, $message);",mdxType:"CodeTabs"}),Object(i.b)(r.b,{text:!0,mdxType:"Result"},"Extensions: Audio, mp4, jpg, jpeg, png, Animation"),Object(i.b)("h2",{id:"groups"},"Groups"),Object(i.b)("p",null,"Resolving a replacement based on a ",Object(i.b)("strong",{parentName:"p"},"whole match")," however, is both uncommon and unpractical. It's much more elastic to resolve\nit based on a specific capturing group, using ",Object(i.b)("inlineCode",{parentName:"p"},"by()->group()->map()"),"."),Object(i.b)("p",null,"Remember, that groups can be matched or not matched, so we need to specify how to\nhandle an unmatched group. In this case, we'll use ",Object(i.b)("inlineCode",{parentName:"p"},"orElseThrow()"),", since we don't\nexpect the group to ever be unmatched."),Object(i.b)(r.a,{tregx:"$links = 'Links: www.google.com, http://socket.io, facebook.com, https://t-regx.com';\n\npattern('(https?://)?(www\\.)?(?<domain>[\\w-]+)\\.(com|io)')\n    ->replace($links)\n    ->all()\n    ->by()\n    ->group('domain')\n    ->map([\n       'google'   => 'Search Engine',\n       'socket'   => 'Documentation',\n       'facebook' => 'Social Portal',\n       't-regx'   => 'Documentation',\n    ])\n    ->orElseThrow();",php:"$links = 'Links: www.google.com, http://socket.io, facebook.com, https://t-regx.com';\n\npreg::replace_callback('#(https?://)?(www\\.)?(?<domain>[\\w-]+)\\.(com|io)#', function (array $match) {\n    // possible invalid group, e.g. \"2group\" or -2\n    validateGroupName('domain');\n\n    $group = $match['domain'];\n    if (!array_key_exists('domain', $match)) {\n        // group is either un-matched or non-existent\n        if (validateGroupExists('domain', $match)) {\n            $group = $match['domain'];\n        } else {\n            throw new NonexistentGroupException('domain');\n        }\n    }\n    if ($match['domain'] === '') {\n        // group is either un-matched or matched an empty string\n        if (validateGroupMatched('domain', $match)) {\n            $group = $match['domain'];\n        } else {\n            throw new GroupNotMatchedException();\n        }\n    }\n\n    $map = [\n        'google'   => 'Search Engine',\n        'socket'   => 'Documentation',\n        'facebook' => 'Social Portal',\n        't-regx'   => 'Documentation',\n    ];\n    if (!array_key_exists($group, $map)) {\n        throw new MissingReplacementKeyException();\n    }\n    $result = $map[$group];\n    if (!is_string($result)) {\n        throw new InvalidArgumentException();\n    }\n    return $result;\n}, $links);",mdxType:"CodeTabs"}),Object(i.b)(r.b,{text:!0,mdxType:"Result"},"Links: Search Engine, Documentation, Social Portal, Documentation"))}m.isMDXComponent=!0}}]);