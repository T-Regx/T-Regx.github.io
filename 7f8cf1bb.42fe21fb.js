(window.webpackJsonp=window.webpackJsonp||[]).push([[71],{154:function(e,a,t){"use strict";t.r(a),t.d(a,"frontMatter",(function(){return l})),t.d(a,"rightToc",(function(){return r})),t.d(a,"default",(function(){return p}));t(217);var n=t(209);function i(){return(i=Object.assign||function(e){for(var a=1;a<arguments.length;a++){var t=arguments[a];for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])}return e}).apply(this,arguments)}const l={id:"prepared-patterns-in-details",title:"Prepared Patterns in details"},r=[{value:"Details about <code>Pattern::prepare()</code>",id:"details-about-patternprepare",children:[{value:"Additional information",id:"additional-information",children:[]}]},{value:"Details about <code>Pattern::inject()</code>",id:"details-about-patterninject",children:[{value:"Ignored placeholders",id:"ignored-placeholders",children:[]},{value:"Additional information",id:"additional-information-1",children:[]}]},{value:"Building process",id:"building-process",children:[]}],b={rightToc:r},c="wrapper";function p({components:e,...a}){return Object(n.b)(c,i({},b,a,{components:e,mdxType:"MDXLayout"}),Object(n.b)("h2",{id:"details-about-patternprepare"},"Details about ",Object(n.b)("inlineCode",{parentName:"h2"},"Pattern::prepare()")),Object(n.b)("p",null,Object(n.b)("inlineCode",{parentName:"p"},"Pattern::prepare()")," accepts your pattern as an array. Said array can contain either:"),Object(n.b)("ul",null,Object(n.b)("li",{parentName:"ul"},Object(n.b)("inlineCode",{parentName:"li"},"string")," - which means it will be interpreted as a regular expression"),Object(n.b)("li",{parentName:"ul"},Object(n.b)("inlineCode",{parentName:"li"},"array")," - it's enclosed values will be treated as string literals.")),Object(n.b)("pre",null,Object(n.b)("code",i({parentName:"pre"},{className:"language-php"}),"Pattern::prepare([\"(My|Our)\", ' ',  \"(dog|cat)'s name is \", [$dog], ' and ', [$cat], '!']);\n")),Object(n.b)("p",null,"The code above means:"),Object(n.b)("ul",null,Object(n.b)("li",{parentName:"ul"},"Treat ",Object(n.b)("inlineCode",{parentName:"li"},'"(My|Our)"')," as a regular expression"),Object(n.b)("li",{parentName:"ul"},"Treat ",Object(n.b)("inlineCode",{parentName:"li"},"' '")," as a regular expression"),Object(n.b)("li",{parentName:"ul"},"Treat ",Object(n.b)("inlineCode",{parentName:"li"},'"(dog|cat)\'s name is "')," as a regular expression"),Object(n.b)("li",{parentName:"ul"},"Treat value of ",Object(n.b)("inlineCode",{parentName:"li"},"$dog")," as a string literal"),Object(n.b)("li",{parentName:"ul"},"Treat ",Object(n.b)("inlineCode",{parentName:"li"},"' and '")," as a regular expression"),Object(n.b)("li",{parentName:"ul"},"Treat value of ",Object(n.b)("inlineCode",{parentName:"li"},"$cat")," as a string literal"),Object(n.b)("li",{parentName:"ul"},"Treat ",Object(n.b)("inlineCode",{parentName:"li"},"'!'")," as a regular expression")),Object(n.b)("p",null,"You can also group elements inside the inner array and also split regular expressions at will:"),Object(n.b)("pre",null,Object(n.b)("code",i({parentName:"pre"},{className:"language-php"}),"Pattern::prepare([\"(My|Our) (dog|cat)'s name is \", [$dog, ' and ', $cat], '!']);\n")),Object(n.b)("p",null,"Both code snippets are equal (but now ",Object(n.b)("inlineCode",{parentName:"p"},"' and '")," is also a string literal)."),Object(n.b)("h3",{id:"additional-information"},"Additional information"),Object(n.b)("ul",null,Object(n.b)("li",{parentName:"ul"},"Array structure:",Object(n.b)("ul",{parentName:"li"},Object(n.b)("li",{parentName:"ul"},"Keys in the arrays (both outer and inner arrays) don't matter, as far as T-Regx is concerned"),Object(n.b)("li",{parentName:"ul"},"The only important factors are:",Object(n.b)("ul",{parentName:"li"},Object(n.b)("li",{parentName:"ul"},"string values"),Object(n.b)("li",{parentName:"ul"},"order of the values inside the array"))))),Object(n.b)("li",{parentName:"ul"},"Data types:",Object(n.b)("ul",{parentName:"li"},Object(n.b)("li",{parentName:"ul"},"The outer array can only consist of ",Object(n.b)("inlineCode",{parentName:"li"},"string")," or an inner array"),Object(n.b)("li",{parentName:"ul"},"The inner array can only consist of ",Object(n.b)("inlineCode",{parentName:"li"},"string")),Object(n.b)("li",{parentName:"ul"},"Any other values cause ",Object(n.b)("inlineCode",{parentName:"li"},"InvalidArgumentException")))),Object(n.b)("li",{parentName:"ul"},"Values inside the inner array:",Object(n.b)("ul",{parentName:"li"},Object(n.b)("li",{parentName:"ul"},Object(n.b)("strong",{parentName:"li"},"don't contribute")," to the pattern being automatically delimited. Otherwise, user-input data could influence the pattern being invalid or not"),Object(n.b)("li",{parentName:"ul"},"are always quoted (using ",Object(n.b)("inlineCode",{parentName:"li"},"preg::quote()"),") with regard to the delimiter chosen by ",Object(n.b)("a",i({parentName:"li"},{href:"/docs/delimiters"}),"Automatic Delimiters"))))),Object(n.b)("h2",{id:"details-about-patterninject"},"Details about ",Object(n.b)("inlineCode",{parentName:"h2"},"Pattern::inject()")),Object(n.b)("p",null,Object(n.b)("inlineCode",{parentName:"p"},"Pattern::inject()")," replaces a ",Object(n.b)("strong",{parentName:"p"},"placeholder")," in the pattern with values treated as string literals."),Object(n.b)("pre",null,Object(n.b)("code",i({parentName:"pre"},{className:"language-php"}),"Pattern::inject(\"(My|Our) (dog|cat)'s name is @dog and @cat!\", [\n    'dog' => $dog,\n    'cat' => $cat\n]);\n")),Object(n.b)("p",null,"The said code snippet with ",Object(n.b)("inlineCode",{parentName:"p"},"Pattern::inject()")," is exactly the same as the one with ",Object(n.b)("inlineCode",{parentName:"p"},"Pattern::prepare()")," above."),Object(n.b)("p",null,"Apart from ",Object(n.b)("inlineCode",{parentName:"p"},"@name")," placeholder format, you can also use ",Object(n.b)("code",null,"`","name","`")," format. So, again, the code snippet below\nworks exactly the same as the two snippets above."),Object(n.b)("pre",null,Object(n.b)("code",i({parentName:"pre"},{className:"language-php"}),"Pattern::inject(\"(My|Our) (dog|cat)'s name is `dog` and `cat`!\", [\n    'dog' => $dog,\n    'cat' => $cat\n]);\n")),Object(n.b)("h3",{id:"ignored-placeholders"},"Ignored placeholders"),Object(n.b)("p",null,"If you'd like to use a placeholder format inside your ",Object(n.b)("inlineCode",{parentName:"p"},"Pattern::inject()"),", but ",Object(n.b)("strong",{parentName:"p"},"not")," replace it with a quoted value,\nyou can ignore it."),Object(n.b)("p",null,"Ignoring a placeholder is done by passing it's name without a replacement:"),Object(n.b)("pre",null,Object(n.b)("code",i({parentName:"pre"},{className:"language-php"}),"Pattern::inject(\"(My|Our) (dog|cat)'s name is @dog and @cat!\", [\n    'dog' => $dog,\n    'cat'               // @cat will not be replaced\n]);\n")),Object(n.b)("p",null,"You can, of course, pass a name and it's corresponding value:"),Object(n.b)("pre",null,Object(n.b)("code",i({parentName:"pre"},{className:"language-php"}),"Pattern::inject(\"(My|Our) (dog|cat)'s name is `dog` and `cat`!\", [\n    'dog' => $dog,\n    'cat' => '`cat`'    // `cat` will be replaced with `cat`\n]);\n")),Object(n.b)("p",null,"but you need to specify which placeholder format was used: ",Object(n.b)("code",null,"`","cat","`")," or ",Object(n.b)("inlineCode",{parentName:"p"},"@cat"),"."),Object(n.b)("h3",{id:"additional-information-1"},"Additional information"),Object(n.b)("pre",null,Object(n.b)("code",i({parentName:"pre"},{className:"language-php"}),"$input = 'Regular expression @name';\n$values = [\n    'name' => 'value'\n];\nPattern::inject($input, $values);\n")),Object(n.b)("ul",null,Object(n.b)("li",{parentName:"ul"},Object(n.b)("p",{parentName:"li"},"Data:"),Object(n.b)("ul",{parentName:"li"},Object(n.b)("li",{parentName:"ul"},"Value of ",Object(n.b)("inlineCode",{parentName:"li"},"$input")," is treated as a regular expression"),Object(n.b)("li",{parentName:"ul"},"Values in ",Object(n.b)("inlineCode",{parentName:"li"},"$values")," are treated as a string literal"))),Object(n.b)("li",{parentName:"ul"},Object(n.b)("p",{parentName:"li"},"Data structure"),Object(n.b)("ul",{parentName:"li"},Object(n.b)("li",{parentName:"ul"},"Each placeholder (",Object(n.b)("inlineCode",{parentName:"li"},"@name")," or ",Object(n.b)("code",null,"`","name","`"),") ",Object(n.b)("strong",{parentName:"li"},"must")," have a counterpart in ",Object(n.b)("inlineCode",{parentName:"li"},"$values"),":",Object(n.b)("ul",{parentName:"li"},Object(n.b)("li",{parentName:"ul"},"a key"),Object(n.b)("li",{parentName:"ul"},"a value, if it's ignored"))),Object(n.b)("li",{parentName:"ul"},"Each key or ignored value in ",Object(n.b)("inlineCode",{parentName:"li"},"$values")," ",Object(n.b)("strong",{parentName:"li"},"must")," have a corresponding placeholder in ",Object(n.b)("inlineCode",{parentName:"li"},"$input")),Object(n.b)("li",{parentName:"ul"},"Placeholder/name/key can only consist of alphanumeric values and an underscore (",Object(n.b)("inlineCode",{parentName:"li"},"[a-zA-Z0-9_]"),")"),Object(n.b)("li",{parentName:"ul"},"If not, ",Object(n.b)("inlineCode",{parentName:"li"},"InvalidArgumentException")," is thrown"))),Object(n.b)("li",{parentName:"ul"},Object(n.b)("p",{parentName:"li"},"Data types:"),Object(n.b)("ul",{parentName:"li"},Object(n.b)("li",{parentName:"ul"},"Values in ",Object(n.b)("inlineCode",{parentName:"li"},"$values")," can only be of type ",Object(n.b)("inlineCode",{parentName:"li"},"string")),Object(n.b)("li",{parentName:"ul"},"If not, ",Object(n.b)("inlineCode",{parentName:"li"},"InvalidArgumentException")," is thrown"))),Object(n.b)("li",{parentName:"ul"},Object(n.b)("p",{parentName:"li"},"Values in ",Object(n.b)("inlineCode",{parentName:"p"},"$values"),":"),Object(n.b)("ul",{parentName:"li"},Object(n.b)("li",{parentName:"ul"},"are always quoted (using ",Object(n.b)("inlineCode",{parentName:"li"},"preg::quote()"),") with regard to the delimiter chosen by ",Object(n.b)("a",i({parentName:"li"},{href:"/docs/delimiters"}),"Automatic Delimiters")),Object(n.b)("li",{parentName:"ul"},Object(n.b)("strong",{parentName:"li"},"don't contribute")," to the pattern being automatically delimited. Otherwise, user-input data could influence the pattern being invalid or not")))),Object(n.b)("h2",{id:"building-process"},"Building process"),Object(n.b)("p",null,"Here's how a given pattern is constructed:"),Object(n.b)("pre",null,Object(n.b)("code",i({parentName:"pre"},{className:"language-php"}),"Pattern::prepare([\"(My|Our)\", ' ',  \"(dog|cat)'s name is \", [$dog], ' and ', [$cat], '!']);\n")),Object(n.b)("p",null,"for values:"),Object(n.b)("pre",null,Object(n.b)("code",i({parentName:"pre"},{className:"language-php"}),"$dog = '192.168.0.1';\n$cat = '(?name';\n")),Object(n.b)("p",null,"Process:"),Object(n.b)("ul",null,Object(n.b)("li",{parentName:"ul"},Object(n.b)("inlineCode",{parentName:"li"},"[\"(My|Our)\", ' ', \"(dog|cat)'s name is \", [$dog], ' and ', [$cat], '!']")),Object(n.b)("li",{parentName:"ul"},"Values supposed to be treated as string literals are cut out"),Object(n.b)("li",{parentName:"ul"},Object(n.b)("inlineCode",{parentName:"li"},"[\"(My|Our)\", ' ', \"(dog|cat)'s name is \", ' and ', '!']")),Object(n.b)("li",{parentName:"ul"},"Pattern is then imploded"),Object(n.b)("li",{parentName:"ul"},Object(n.b)("inlineCode",{parentName:"li"},'"(My|Our) (dog|cat)\'s name is and !"')),Object(n.b)("li",{parentName:"ul"},Object(n.b)("a",i({parentName:"li"},{href:"/docs/delimiters"}),"Automatic Delimiters")," are used to chose the delimiter"),Object(n.b)("li",{parentName:"ul"},"The pattern is being checked:",Object(n.b)("ul",{parentName:"li"},Object(n.b)("li",{parentName:"ul"},"whether it's already delimiter, and if it is:",Object(n.b)("ul",{parentName:"li"},Object(n.b)("li",{parentName:"ul"},"what delimiter is used exactly"),Object(n.b)("li",{parentName:"ul"},"whether it's used with flags"))),Object(n.b)("li",{parentName:"ul"},"and if it's not, a suitable delimiter is chosen automatically"))),Object(n.b)("li",{parentName:"ul"},"In this case, ",Object(n.b)("inlineCode",{parentName:"li"},"/")," is chosen"),Object(n.b)("li",{parentName:"ul"},"Values supposed to be treated as string literals are quoted using the delimiter"),Object(n.b)("li",{parentName:"ul"},Object(n.b)("pre",{parentName:"li"},Object(n.b)("code",i({parentName:"pre"},{}),"[\"(My|Our)\", ' ',  \"(dog|cat)'s name is \", preg::quote($dog, '/'), ' and ', preg::quote($cat, '/'), '!']\n"))),Object(n.b)("li",{parentName:"ul"},"The final pattern is joined, flags are appended and the pattern is returned",Object(n.b)("pre",{parentName:"li"},Object(n.b)("code",i({parentName:"pre"},{className:"language-regexp"}),"/(My|Our) (dog|cat)'s name is 192\\.168\\.0\\.1 and \\(\\?name!/\n")))))}p.isMDXComponent=!0}}]);