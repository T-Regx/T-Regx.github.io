(window.webpackJsonp=window.webpackJsonp||[]).push([[79],{141:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return p})),n.d(t,"metadata",(function(){return o})),n.d(t,"rightToc",(function(){return l})),n.d(t,"default",(function(){return b}));var a=n(2),r=n(6),i=(n(0),n(168)),p={id:"prepared-patterns",title:"Prepared Patterns - User input"},o={unversionedId:"prepared-patterns",id:"prepared-patterns",isDocsHomePage:!1,title:"Prepared Patterns - User input",description:"If you use Pattern::inject(), you can explicitly specify which parts of your pattern",source:"@site/..\\docs\\prepared-patterns.md",permalink:"/docs/prepared-patterns",lastUpdatedAt:1599992270,sidebar:"docs",previous:{title:"Handling user input",permalink:"/docs/handling-user-input"},next:{title:"Composite Pattern",permalink:"/docs/composite-pattern"}},l=[{value:"Use-case",id:"use-case",children:[{value:"With <code>Pattern::inject()</code>",id:"with-patterninject",children:[]},{value:"With <code>Pattern::bind()</code>",id:"with-patternbind",children:[]}]},{value:"Old-school pattern quoting",id:"old-school-pattern-quoting",children:[]}],c={rightToc:l};function b(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(i.b)("wrapper",Object(a.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,"If you use ",Object(i.b)("inlineCode",{parentName:"p"},"Pattern::bind()")," or ",Object(i.b)("inlineCode",{parentName:"p"},"Pattern::inject()"),", you can explicitly specify which parts of your pattern\nshould be treated as string literals, and not as regular expression special characters."),Object(i.b)("p",null,"Prepared Patterns also understand that strings, that are supposed to be treated as string literals, are to be\nquoted with a delimiter, that was chosen with ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/delimiters"}),"Automatic Delimiters"),"."),Object(i.b)("h2",{id:"use-case"},"Use-case"),Object(i.b)("p",null,"When you need to use unsafe data in your patterns, it might be tempting to do something like this:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-php"}),"// build the pattern\n$pattern = Pattern::of('^https://' . $_GET['domain'] . '\\.(com|net)');\n\n// use the pattern\n$pattern->test($string);\n")),Object(i.b)("p",null,"But you, dear reader, know that it's a terrible, terrible idea. ",Object(i.b)("inlineCode",{parentName:"p"},"$_GET['domain']")," may contain\nunexpected/malicious regular expression characters."),Object(i.b)("p",null,"Because:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("inlineCode",{parentName:"p"},"^https://")," must be treated ",Object(i.b)("strong",{parentName:"p"},"as a regular expression")," "),Object(i.b)("blockquote",{parentName:"li"},Object(i.b)("p",{parentName:"blockquote"},"Character ",Object(i.b)("inlineCode",{parentName:"p"},"^"),' must mean "start of the string"'))),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("inlineCode",{parentName:"p"},"$_GET['domain']")," must be treated ",Object(i.b)("strong",{parentName:"p"},"as a string")," "),Object(i.b)("blockquote",{parentName:"li"},Object(i.b)("p",{parentName:"blockquote"},"If there's ",Object(i.b)("inlineCode",{parentName:"p"},".")," in the string, it ",Object(i.b)("strong",{parentName:"p"},"must not"),' mean "any character" (like regex would).\nAny special meaning of regex symbols (like ',Object(i.b)("inlineCode",{parentName:"p"},"."),", ",Object(i.b)("inlineCode",{parentName:"p"},"?"),") must be revoked."))),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("inlineCode",{parentName:"p"},"\\.(com|net)")," must be treated ",Object(i.b)("strong",{parentName:"p"},"as a regular expression")," "),Object(i.b)("blockquote",{parentName:"li"},Object(i.b)("p",{parentName:"blockquote"},"Expression ",Object(i.b)("inlineCode",{parentName:"p"},"(com|net)")," must bean alteration.")))),Object(i.b)("p",null,"That's a use-case for prepared patterns."),Object(i.b)("h3",{id:"with-patterninject"},"With ",Object(i.b)("inlineCode",{parentName:"h3"},"Pattern::inject()")),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"Pattern::inject()")," allows you to specify ",Object(i.b)("inlineCode",{parentName:"p"},"@")," placeholder in your pattern, which\nwill later be populated with ",Object(i.b)("strong",{parentName:"p"},"safe")," version of your parameter."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-php"}),"$pattern = Pattern::inject(\"https?://@/index\\.php\", [$_GET['domain']]);\n\n$pattern->test($string);\n")),Object(i.b)("p",null,"The code above means:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Treat ",Object(i.b)("inlineCode",{parentName:"li"},"https?://")," and ",Object(i.b)("inlineCode",{parentName:"li"},"/index\\.php")," as regexp"),Object(i.b)("li",{parentName:"ul"},"Treat ",Object(i.b)("inlineCode",{parentName:"li"},"@")," as a string literal"),Object(i.b)("li",{parentName:"ul"},"Replace ",Object(i.b)("inlineCode",{parentName:"li"},"@")," with ",Object(i.b)("inlineCode",{parentName:"li"},"$_GET['domain']"),", but handling all regexp special characters.")),Object(i.b)("h3",{id:"with-patternbind"},"With ",Object(i.b)("inlineCode",{parentName:"h3"},"Pattern::bind()")),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"Pattern::bind()")," is a bit more verbose version of ",Object(i.b)("inlineCode",{parentName:"p"},"Pattern::inject()"),"."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-php"}),"$pattern = Pattern::bind(\"(My|Our) dog's name is @name! @name is great!\", [\n    'name' => $_GET['input']\n]);\n\n$pattern->test($string);\n")),Object(i.b)("p",null,"For example, it allows you to reuse your parameters, when they're used more than once in the pattern."),Object(i.b)("p",null,"The code above means:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Treat ",Object(i.b)("inlineCode",{parentName:"li"},"$_GET['input']")," as a string literal"),Object(i.b)("li",{parentName:"ul"},"Replace ",Object(i.b)("inlineCode",{parentName:"li"},"@name")," with ",Object(i.b)("inlineCode",{parentName:"li"},"$_GET['input']"),", but handling all regexp special characters.")),Object(i.b)("h2",{id:"old-school-pattern-quoting"},"Old-school pattern quoting"),Object(i.b)("p",null,"Have you chosen to work with regular PCRE functions, your code might look similar to this:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-php"}),"preg_match('/(Pattern|pattern) with ' . preg_quote('quoted parts...', '/') . ' is ugly/');\n")),Object(i.b)("p",null,"Prepared Patterns address some of this approach flaws. They:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"automatically delimiter your input, so there's no need for specifying the delimiter again in ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"https://www.php.net/manual/en/function.preg-quote.php"}),Object(i.b)("inlineCode",{parentName:"a"},"preg_quote()")),"."),Object(i.b)("li",{parentName:"ul"},"are declarative. Meaning, you only need to ",Object(i.b)("em",{parentName:"li"},"declare")," that you want those values to be treated as string literals."),Object(i.b)("li",{parentName:"ul"},"fix inconsistency with ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"https://www.php.net/manual/en/function.preg-quote.php"}),Object(i.b)("inlineCode",{parentName:"a"},"preg_quote()"))," returning different values since PHP 7.3")),Object(i.b)("p",null,"They also add additional functionality, that currently is utterly missing in PHP:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"flag ",Object(i.b)("inlineCode",{parentName:"li"},"x")," ignores whitespaces, so large expressions can be split to multiple lines. ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"https://www.php.net/manual/en/function.preg-quote.php"}),Object(i.b)("inlineCode",{parentName:"a"},"preg_quote()"))," doesn't quote spaces,\nso user-input spaces are also going to be ignored - Prepared Patterns will however preserve them.")))}b.isMDXComponent=!0},168:function(e,t,n){"use strict";n.d(t,"a",(function(){return s})),n.d(t,"b",(function(){return m}));var a=n(0),r=n.n(a);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function p(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?p(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):p(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=r.a.createContext({}),b=function(e){var t=r.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},s=function(e){var t=b(e.components);return r.a.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},d=r.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,p=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),s=b(n),d=a,m=s["".concat(p,".").concat(d)]||s[d]||u[d]||i;return n?r.a.createElement(m,o(o({ref:t},c),{},{components:n})):r.a.createElement(m,o({ref:t},c))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,p=new Array(i);p[0]=d;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:a,p[1]=o;for(var c=2;c<i;c++)p[c]=n[c];return r.a.createElement.apply(null,p)}return r.a.createElement.apply(null,n)}d.displayName="MDXCreateElement"}}]);