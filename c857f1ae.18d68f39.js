(window.webpackJsonp=window.webpackJsonp||[]).push([[104],{185:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return i})),a.d(t,"rightToc",(function(){return l})),a.d(t,"default",(function(){return c}));a(215);var n=a(207);function r(){return(r=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var a=arguments[t];for(var n in a)Object.prototype.hasOwnProperty.call(a,n)&&(e[n]=a[n])}return e}).apply(this,arguments)}const i={id:"prepared-patterns",title:"Prepared Patterns - User input"},l=[{value:"Old-school pattern quoting",id:"old-school-pattern-quoting",children:[]},{value:"Using prepared patterns",id:"using-prepared-patterns",children:[{value:"With <code>Pattern::prepare()</code>",id:"with-patternprepare",children:[]},{value:"With <code>Pattern::inject()</code>",id:"with-patterninject",children:[]},{value:"Usage",id:"usage",children:[]}]}],p={rightToc:l},b="wrapper";function c({components:e,...t}){return Object(n.b)(b,r({},p,t,{components:e,mdxType:"MDXLayout"}),Object(n.b)("h2",{id:"old-school-pattern-quoting"},"Old-school pattern quoting"),Object(n.b)("p",null,"Have you chosen to work with regular PCRE functions, your code might look similar to this:"),Object(n.b)("pre",null,Object(n.b)("code",r({parentName:"pre"},{className:"language-php"}),"preg_match('/(Pattern|pattern) with ' . preg_quote('quoted parts...', '/') . ' is ugly/');\n")),Object(n.b)("p",null,"Prepared Patterns address some of this approach flaws. They:"),Object(n.b)("ul",null,Object(n.b)("li",{parentName:"ul"},"automatically delimiter your input, so there's no need for specifying ",Object(n.b)("inlineCode",{parentName:"li"},"/")," delimiter again in ",Object(n.b)("inlineCode",{parentName:"li"},"preg_quote()"),"."),Object(n.b)("li",{parentName:"ul"},"are declarative. Meaning, you only need to ",Object(n.b)("em",{parentName:"li"},"declare")," that you want those values to be treated as string literals."),Object(n.b)("li",{parentName:"ul"},"fix inconsistency with ",Object(n.b)("inlineCode",{parentName:"li"},"preg_quote()")," returning different values since PHP 7.3")),Object(n.b)("p",null,"They also add additional functionality, that currently is utterly missing in PHP:"),Object(n.b)("ul",null,Object(n.b)("li",{parentName:"ul"},"un-quoting values inside ",Object(n.b)("inlineCode",{parentName:"li"},"\\Q")," and ",Object(n.b)("inlineCode",{parentName:"li"},"\\E"),", which indicate quote in PHP regular expressions."),Object(n.b)("li",{parentName:"ul"},"flag ",Object(n.b)("inlineCode",{parentName:"li"},"x")," ignores whitespaces, so large expressions can be split to multiple lines. ",Object(n.b)("inlineCode",{parentName:"li"},"preg_quote()")," doesn't quote spaces,\nso user-input spaces are also going to be ignored - Prepared Patterns will however preserve them.")),Object(n.b)("p",null,"This is done to relieve you from the ",Object(n.b)("a",r({parentName:"p"},{href:"/docs/overview#brain-strain"}),Object(n.b)("strong",{parentName:"a"},"brain strain")),"."),Object(n.b)("p",null,"Basically,"),Object(n.b)("ul",null,Object(n.b)("li",{parentName:"ul"},Object(n.b)("inlineCode",{parentName:"li"},"preg_quote()")," is procedural - you take care of everything by yourself"),Object(n.b)("li",{parentName:"ul"},"Prepared Patterns are declarative - we take care of everything ",Object(n.b)("strong",{parentName:"li"},"for")," you")),Object(n.b)("h2",{id:"using-prepared-patterns"},"Using prepared patterns"),Object(n.b)("p",null,"If you use ",Object(n.b)("inlineCode",{parentName:"p"},"Pattern::prepare()")," or ",Object(n.b)("inlineCode",{parentName:"p"},"Pattern::inject()"),", you can explicitly specify which parts of your pattern should be\ntreated as string literals, and not as regular expression special characters."),Object(n.b)("p",null,"Prepared Patterns also understand that strings that are supposed to be treated as string literals are to be quoted with a\ndelimiter, that was chosen with ",Object(n.b)("a",r({parentName:"p"},{href:"/docs/delimiters"}),"Automatic Delimiters"),"."),Object(n.b)("h3",{id:"with-patternprepare"},"With ",Object(n.b)("inlineCode",{parentName:"h3"},"Pattern::prepare()")),Object(n.b)("p",null,Object(n.b)("inlineCode",{parentName:"p"},"Pattern::prepare()")," accepts your pattern as an array. Said array can contain either:"),Object(n.b)("ul",null,Object(n.b)("li",{parentName:"ul"},Object(n.b)("inlineCode",{parentName:"li"},"string")," - that will be interpreted as a regular expression"),Object(n.b)("li",{parentName:"ul"},Object(n.b)("inlineCode",{parentName:"li"},"array")," - that values of which will be treated as string literals")),Object(n.b)("pre",null,Object(n.b)("code",r({parentName:"pre"},{className:"language-php"}),"$input = $_GET['input'];\n\nPattern::prepare([\"(My|Our) dog's name is \", [$input], '!']);\n")),Object(n.b)("p",null,"The code above means:"),Object(n.b)("ul",null,Object(n.b)("li",{parentName:"ul"},"Treat ",Object(n.b)("inlineCode",{parentName:"li"},'"(My|Our) dog\'s name is "')," as a regular expression"),Object(n.b)("li",{parentName:"ul"},"Treat ",Object(n.b)("inlineCode",{parentName:"li"},"$input")," as a string literal"),Object(n.b)("li",{parentName:"ul"},"Treat ",Object(n.b)("inlineCode",{parentName:"li"},"'!'")," as a regular expression")),Object(n.b)("h3",{id:"with-patterninject"},"With ",Object(n.b)("inlineCode",{parentName:"h3"},"Pattern::inject()")),Object(n.b)("p",null,"For a bit cleaner pattern, consider using ",Object(n.b)("inlineCode",{parentName:"p"},"Pattern::inject()"),"."),Object(n.b)("p",null,"It replaces a ",Object(n.b)("strong",{parentName:"p"},"placeholder")," in the pattern with values treated as string literals."),Object(n.b)("pre",null,Object(n.b)("code",r({parentName:"pre"},{className:"language-php"}),"$input = $_GET['input'];\n\nPattern::inject(\"(My|Our) dog's name is @name!\", [\n    'name' => $input\n]);\n")),Object(n.b)("p",null,"The code above means:"),Object(n.b)("ul",null,Object(n.b)("li",{parentName:"ul"},"Treat ",Object(n.b)("inlineCode",{parentName:"li"},"$input")," as a string literal"),Object(n.b)("li",{parentName:"ul"},Object(n.b)("inlineCode",{parentName:"li"},"$input")," is assigned to ",Object(n.b)("inlineCode",{parentName:"li"},"name"),", so find ",Object(n.b)("inlineCode",{parentName:"li"},"@name")," in the pattern"),Object(n.b)("li",{parentName:"ul"},"Replace ",Object(n.b)("inlineCode",{parentName:"li"},"@name")," with ",Object(n.b)("inlineCode",{parentName:"li"},"$input"),", but handling all regexp special characters.")),Object(n.b)("h3",{id:"usage"},"Usage"),Object(n.b)("p",null,"And that's it! Prepared patterns are exactly alike to regular ",Object(n.b)("inlineCode",{parentName:"p"},"pattern()"),"/",Object(n.b)("inlineCode",{parentName:"p"},"Pattern::of()"),". Below snippets are identical:"),Object(n.b)("pre",null,Object(n.b)("code",r({parentName:"pre"},{className:"language-php"}),"Pattern::prepare([\"(My|Our) dog's name is \", [$input], '!'])->match($subject)->first();\n")),Object(n.b)("pre",null,Object(n.b)("code",r({parentName:"pre"},{className:"language-php"}),'Pattern::of("(My|Our) dog\'s name is Barky!")->match($subject)->first();\n')),Object(n.b)("p",null,"except for the fact that ",Object(n.b)("inlineCode",{parentName:"p"},"$input")," can be user-input, guaranteed to be safe."))}c.isMDXComponent=!0}}]);