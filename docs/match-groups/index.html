<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Capturing groups · T-Regx</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="&lt;p&gt;When using &lt;code&gt;pattern()-&amp;gt;match()&lt;/code&gt; and &lt;code&gt;-&amp;gt;replace-&amp;gt;callback()&lt;/code&gt;, some methods receive a callback that accepts&lt;/p&gt;
"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Capturing groups · T-Regx"/><meta property="og:type" content="website"/><meta property="og:url" content="https://t-regx.com/"/><meta property="og:description" content="&lt;p&gt;When using &lt;code&gt;pattern()-&amp;gt;match()&lt;/code&gt; and &lt;code&gt;-&amp;gt;replace-&amp;gt;callback()&lt;/code&gt;, some methods receive a callback that accepts&lt;/p&gt;
"/><meta property="og:image" content="https://t-regx.com//img/docusaurus.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://t-regx.com//img/docusaurus.png"/><link rel="shortcut icon" href="/img/favicon.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css"/><link rel="alternate" type="application/atom+xml" href="https://t-regx.com/blog/atom.xml" title="T-Regx Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://t-regx.com/blog/feed.xml" title="T-Regx Blog RSS Feed"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script><script type="text/javascript" src="/js/code-block-buttons.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100,"showWhenScrollTopIs":190,"scrollDuration":400,"backgroundColor":"#26768c"}
          )
        });
        </script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/t.regx.borderless.png" alt="T-Regx"/><h2 class="headerTitleWithLogo">T-Regx</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search the website" title="Search the website"/></li><li class="siteNavGroupActive"><a href="/docs/installation" target="_self">Docs</a></li><li class=""><a href="/comparison" target="_self">Compare</a></li><li class=""><a href="/help" target="_self">Help</a></li><li class=""><a href="/blog/" target="_self">Blog</a></li><li class=""><a href="https://github.com/T-Regx/T-Regx" target="_blank">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Match Details</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">About</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/overview">What&#x27;s T-Regx?</a></li><li class="navListItem"><a class="navItem" href="/docs/whats-the-point">Why would I use T-Regx?</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Kick Start</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/installation">Installation</a></li><li class="navListItem"><a class="navItem" href="/docs/introduction">Introduction</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Matching</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/match">Match a subject</a></li><li class="navListItem"><a class="navItem" href="/docs/match-first">First occurrence</a></li><li class="navListItem"><a class="navItem" href="/docs/match-for-first">Optional matches</a></li><li class="navListItem"><a class="navItem" href="/docs/match-for-each">For Each/Iterate</a></li><li class="navListItem"><a class="navItem" href="/docs/match-map">Map occurrences</a></li><li class="navListItem"><a class="navItem" href="/docs/match-flat-map">Map with keys (Flat map)</a></li><li class="navListItem"><a class="navItem" href="/docs/match-iterator">Iterator</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Replacing</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/replace">Replacing a string</a></li><li class="navListItem"><a class="navItem" href="/docs/replace-with">Replace with a constant value</a></li><li class="navListItem"><a class="navItem" href="/docs/replace-callback">Replace with callback</a></li><li class="navListItem"><a class="navItem" href="/docs/replace-by-group">Replace by group</a></li><li class="navListItem"><a class="navItem" href="/docs/replace-by-map">Replace by map</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Match Details</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/match-details">Match details</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/match-groups">Capturing groups</a></li><li class="navListItem"><a class="navItem" href="/docs/match-offsets">Match offsets</a></li><li class="navListItem"><a class="navItem" href="/docs/match-group">Inline groups</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Prepared Patterns</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/handling-user-input">Handling user input</a></li><li class="navListItem"><a class="navItem" href="/docs/prepared-patterns">Prepared Patterns - User input</a></li><li class="navListItem"><a class="navItem" href="/docs/composite-pattern">Composite Pattern</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Misc</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/delimiters">Automatic delimiters</a></li><li class="navListItem"><a class="navItem" href="/docs/count">Count occurrences</a></li><li class="navListItem"><a class="navItem" href="/docs/quoting">Quoting</a></li><li class="navListItem"><a class="navItem" href="/docs/is-valid">Validate a pattern</a></li><li class="navListItem"><a class="navItem" href="/docs/split">Split a string</a></li><li class="navListItem"><a class="navItem" href="/docs/filter">Filter an array</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Advanced</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/replace-match-details">Advanced replace details</a></li><li class="navListItem"><a class="navItem" href="/docs/prepared-patterns-in-details">Prepared Patterns in details</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              const headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                if (event.target.tagName === 'A') {
                  document.body.classList.remove('tocActive');
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">Capturing groups</h1></header><article><div><span><p>When using <code>pattern()-&gt;match()</code> and <code>-&gt;replace-&gt;callback()</code>, some methods receive a callback that accepts
<a href="/docs/match-details"><code>Match</code></a> details object. These methods are:
<a href="/docs/match-first"><code>first()</code></a>,
<a href="/docs/match-for-first"><code>forFirst()</code></a>,
<a href="/docs/match-for-each"><code>forEach()</code></a>/<a href="/docs/match-for-each"><code>iterate()</code></a>,
<a href="/docs/match-map"><code>map()</code></a>,
<a href="/docs/match-flat-map"><code>flatMap()</code></a>,
<a href="/docs/replace-callback"><code>callback()</code></a>.</p>
<!-- Copy the above paragraph to match-details.md -->
<h2><a class="anchor" aria-hidden="true" id="overview"></a><a href="#overview" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Overview</h2>
<blockquote>
<p>This page only concerns <strong>capturing groups</strong> of <a href="/docs/match-details"><code>Match</code></a>, specifically. See <a href="/docs/match-details"><code>Match</code></a> details for more throughout documentation.</p>
</blockquote>
<p>Using <a href="/docs/match-details"><code>Match</code></a> details, you gain access complete information about capturing groups:</p>
<ul>
<li><a href="#group-details"><code>group(int|string)</code></a> - capturing group details. If group is matched, below methods are available:
<ul>
<li><code>matched()</code> - whether the group was matched by the subject</li>
<li><code>text()</code> - value of the group</li>
<li><code>parseInt()</code>/<code>isInt()</code> - allow you to handle integers safely</li>
<li><a href="#offsets">offsets of matched values</a> in the subject:
<ul>
<li>character offsets (UTF-8 safe) - <code>offset()</code></li>
<li>byte offsets - <code>byteOffset()</code></li>
</ul></li>
</ul></li>
<li><a href="#optional-groups"><code>orReturn()</code></a>/<a href="#optional-groups"><code>orElse()</code></a>/<a href="#optional-groups"><code>orThrow()</code></a> - returns a group, or controls the absence of the group</li>
<li><a href="#index-name-and-identifier"><code>index()</code></a> - ordinal value of the capturing group in a pattern</li>
<li><a href="#index-name-and-identifier"><code>name()</code></a> - name of the capturing group, or <code>null</code> of group is not named</li>
<li><a href="#index-name-and-identifier"><code>usedIdentifier()</code></a> - either <code>index()</code> or <code>name()</code>, depending on the argument of <code>group(int|string)</code></li>
<li><a href="#group-is-matched"><code>matched(int|string)</code></a> - whether the group was matched by the subject</li>
<li><a href="#group-exists"><code>hasGroup(int|string)</code></a> - whether group was used in a pattern</li>
<li><a href="#composite-groups"><code>groups()</code></a>/<a href="#composite-groups"><code>namedGroups()</code></a> - interface for composite operations for all groups</li>
<li><a href="#group-names"><code>groupNames()</code></a> - string list of named groups used in a pattern</li>
<li><a href="#groups-count"><code>groupsCount()</code></a> - counts number of capturing groups (without duplicates of named and regular groups)</li>
<li><a href="#other-occurrences"><code>all()</code></a> - other matched occurrences of the group</li>
</ul>
<blockquote>
<p>With PHP, all groups' syntax: <code>(?&lt;name&gt;)</code>, <code>(?'name')</code> and <code>(?P&lt;name&gt;)</code> are considered &quot;named&quot;. Regular, indexed groups
are use with syntax <code>()</code>. Group <code>(?:)</code> is considered a non-capturing group.</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="group-details"></a><a href="#group-details" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Group details</h2>
<pre><code class="hljs css language-php">$p = <span class="hljs-string">'(?&lt;value&gt;\d+)(?&lt;unit&gt;cm|mm)'</span>;
$s = <span class="hljs-string">'192mm and 168cm or 18mm and 12cm'</span>;

pattern($p) -&gt;match($s) -&gt;iterate(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(Match $match)</span> </span>{
    
    $match-&gt;group(<span class="hljs-string">'value'</span>)-&gt;text()      <span class="hljs-comment">// '168' (string)</span>
    $match-&gt;group(<span class="hljs-string">'value'</span>)-&gt;isInt()     <span class="hljs-comment">// true  (boolean)</span>
    $match-&gt;group(<span class="hljs-string">'value'</span>)-&gt;parseInt()  <span class="hljs-comment">// 168   (int)</span>
    
    $match-&gt;group(<span class="hljs-string">'unit'</span>)-&gt;offset()     <span class="hljs-comment">// 13</span>
    $match-&gt;group(<span class="hljs-string">'unit'</span>)-&gt;text()       <span class="hljs-comment">// 'cm'</span>
    $match-&gt;group(<span class="hljs-string">'unit'</span>)-&gt;isInt()      <span class="hljs-comment">// false</span>
    $match-&gt;group(<span class="hljs-string">'unit'</span>)-&gt;parseInt()   <span class="hljs-comment">// throws IntegerFormatException</span>
    
    $match-&gt;group(<span class="hljs-string">'unit'</span>)-&gt;index()      <span class="hljs-comment">// 2</span>
    $match-&gt;group(<span class="hljs-number">2</span>)-&gt;name()            <span class="hljs-comment">// 'unit'</span>
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="offsets"></a><a href="#offsets" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Offsets</h3>
<h3><a class="anchor" aria-hidden="true" id="optional-groups"></a><a href="#optional-groups" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Optional groups</h3>
<p>Some patterns have required capturing groups, e.g <code>^(cm|mm)$</code>. Others, have capturing groups that are optional,
e.g. <code>\d+(cm|mm)?</code>. As you can see the <code>(cm|mm)</code> doesn't have to be matched for the whole subject to be matched -
both <code>14</code> and <code>14cm</code> are subjects that match the pattern.</p>
<p>Optional groups allow you to deal with potentially unmatched groups with elegance. If the group <strong>is matched</strong>, each of the methods:</p>
<ul>
<li><code>text()</code></li>
<li><code>orReturn()</code></li>
<li><code>orElse()</code></li>
<li><code>orThrow()</code></li>
</ul>
<p>work exactly the same.</p>
<pre><code class="hljs css language-php">pattern(<span class="hljs-string">'(?&lt;schema&gt;http://)?\w+\.\w+'</span>)-&gt;match(<span class="hljs-string">'http://google.com'</span>)-&gt;first(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(Match $match)</span> </span>{
    $match-&gt;group(<span class="hljs-string">'schema'</span>)-&gt;text();                  <span class="hljs-comment">// 'http://'</span>
    $match-&gt;group(<span class="hljs-string">'schema'</span>)-&gt;orThrow();               <span class="hljs-comment">// 'http://'</span>
    $match-&gt;group(<span class="hljs-string">'schema'</span>)-&gt;orReturn(<span class="hljs-string">'other'</span>);       <span class="hljs-comment">// 'http://'</span>
    $match-&gt;group(<span class="hljs-string">'schema'</span>)-&gt;orElse(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{      <span class="hljs-comment">// 'http://'</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>;
    });  
});
</code></pre>
<p>The difference is - how they work when then group is not matched:</p>
<pre><code class="hljs css language-php">pattern(<span class="hljs-string">'(?&lt;schema&gt;https?://)?\w+\.\w+'</span>)-&gt;match(<span class="hljs-string">'google.com'</span>)-&gt;first(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(Match $match)</span> </span>{
    $match-&gt;group(<span class="hljs-string">'schema'</span>)-&gt;text();                  <span class="hljs-comment">// `GroupNotMatchedException`</span>
    $match-&gt;group(<span class="hljs-string">'schema'</span>)-&gt;orThrow();               <span class="hljs-comment">// `GroupNotMatchedException` by default</span>
    $match-&gt;group(<span class="hljs-string">'schema'</span>)-&gt;orReturn(<span class="hljs-string">'other'</span>);       <span class="hljs-comment">// 'other'</span>
    $match-&gt;group(<span class="hljs-string">'schema'</span>)-&gt;orElse(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{      <span class="hljs-comment">// whatever is returned, in this case: ''</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>;
    });   
});
</code></pre>
<p>Method <code>group()-&gt;orThrow()</code> works exactly the same as <code>forFirst()-&gt;orThrow()</code>, which means it accepts user defined exception
to instantiate:</p>
<pre><code class="hljs css language-php"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Exception</span> </span>{}

pattern(<span class="hljs-string">'(?&lt;schema&gt;https?://)?\w+\.\w+'</span>)-&gt;match(<span class="hljs-string">'google.com'</span>)-&gt;first(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(Match $match)</span> </span>{
    $match-&gt;group(<span class="hljs-string">'schema'</span>)-&gt;orThrow(MyException::class);  <span class="hljs-comment">// `MyException`</span>
});
</code></pre>
<blockquote>
<p>Method <code>group()-&gt;orThrow()</code> throws <code>GroupNotMatchedException</code> by default, so - when called without user defined exception -
it's actually identical to <code>group()-&gt;text()</code>.</p>
</blockquote>
<blockquote>
<p>Method <code>group()-&gt;orElse(callable)</code> callback receives <code>NotMatched</code>, just like <code>forFirst()-&gt;orElse()</code>.</p>
</blockquote>
<h3><a class="anchor" aria-hidden="true" id="index-name-and-identifier"></a><a href="#index-name-and-identifier" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Index, name and identifier</h3>
<p>Groups can be referred to either by index or by name, if the group in a pattern is named. What was the group referred
with is called an identifier. If group was referred by index, then the index is the identifier.</p>
<p>T-Regx has 3 separate methods for each of the group reference method:</p>
<ul>
<li><code>index()</code> - returns the ordinal number of a group</li>
<li><code>name()</code> - returns the name of a group, or <code>null</code> if the group is not named</li>
<li><code>usedIdentifier()</code> - returns either <code>index()</code> or <code>name()</code>, depending on what was the group referred with</li>
</ul>
<pre><code class="hljs css language-php">pattern(<span class="hljs-string">'(?&lt;schema&gt;https?://)?\w+\.\w+'</span>)-&gt;match($subject)-&gt;first(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(Match $match)</span> </span>{
    $match-&gt;group(<span class="hljs-number">1</span>)-&gt;index();                  <span class="hljs-comment">//  1</span>
    $match-&gt;group(<span class="hljs-string">'schema'</span>)-&gt;index();           <span class="hljs-comment">//  1</span>

    $match-&gt;group(<span class="hljs-number">1</span>)-&gt;name();                   <span class="hljs-comment">// 'schema'</span>
    $match-&gt;group(<span class="hljs-string">'schema'</span>)-&gt;name();            <span class="hljs-comment">// 'schema'</span>

    $match-&gt;group(<span class="hljs-number">1</span>)-&gt;usedIdentifier();         <span class="hljs-comment">//  1</span>
    $match-&gt;group(<span class="hljs-string">'schema'</span>)-&gt;usedIdentifier();  <span class="hljs-comment">// 'schema'</span>
});
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="group-is-matched"></a><a href="#group-is-matched" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Group is matched</h2>
<p>Method <code>matched(int|string)</code> allows you to verify whether a given group was matched by the subject:</p>
<pre><code class="hljs css language-php">$subject = <span class="hljs-string">'Links: google.com and http://facebook.com'</span>;

pattern(<span class="hljs-string">'(https?://)?\w+\.\w+'</span>)-&gt;match($subject)-&gt;forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(Match $match)</span> </span>{
    <span class="hljs-comment">// first iteration</span>
    $match-&gt;text();       <span class="hljs-comment">// 'google.com'</span>
    $match-&gt;matched(<span class="hljs-number">1</span>);   <span class="hljs-comment">// false, `google.com` doesn't have a schema </span>
    $match-&gt;group(<span class="hljs-number">1</span>);     <span class="hljs-comment">// GroupNotMatchedException</span>
    
    <span class="hljs-comment">// second iteration</span>
    $match-&gt;text();       <span class="hljs-comment">// 'http://facebook.com'    </span>
    $match-&gt;matched(<span class="hljs-number">1</span>);   <span class="hljs-comment">// true, `http://facebook.com` does have a schema </span>
    $match-&gt;group(<span class="hljs-number">1</span>);     <span class="hljs-comment">// 'http://'    </span>
});
</code></pre>
<p>It'll work just as well with named groups:</p>
<pre><code class="hljs css language-php">pattern(<span class="hljs-string">'(?&lt;schema&gt;https?://)?\w+\.\w+'</span>)-&gt;match($subject)-&gt;first(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(Match $match)</span> </span>{
    $match-&gt;text();              <span class="hljs-comment">// 'google.com'  </span>
    $match-&gt;matched(<span class="hljs-string">'schema'</span>);   <span class="hljs-comment">// false, `google.com` doesn't have a schema </span>
    $match-&gt;group(<span class="hljs-string">'schema'</span>);     <span class="hljs-comment">// GroupNotMatchedException</span>
});
</code></pre>
<p>Although method <code>$match-&gt;matched(int|string)</code> is the preferred way - same effect can be achieved with
using <code>$match-&gt;group(int|string)-&gt;matched()</code>:</p>
<pre><code class="hljs css language-php">pattern(<span class="hljs-string">'(?&lt;schema&gt;https?://)?\w+\.\w+'</span>)-&gt;match($subject)-&gt;first(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(Match $match)</span> </span>{
    $match-&gt;group(<span class="hljs-string">'schema'</span>)-&gt;matched();   <span class="hljs-comment">// false, `google.com` doesn't have a schema</span>
});
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="invalid-groups-and-arguments"></a><a href="#invalid-groups-and-arguments" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Invalid groups and arguments</h4>
<ul>
<li><code>matched()</code> will throw <code>NonexistentGroupException</code>, when used with a non-existent group <em>(i.e. <code>asdf</code>)</em>.</li>
<li><code>matched()</code> will throw <code>\InvalidArgumentException</code>, when used with an invalid group <em>(i.e. <code>2group</code>, <code>-1</code> or any other type than <code>string</code> or <code>int</code>)</em>.</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="group-exists"></a><a href="#group-exists" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Group exists</h2>
<p>Method <code>hasGroup(int|string)</code> allows you to verify whether the group was used in a pattern:</p>
<pre><code class="hljs css language-php">pattern(<span class="hljs-string">'(?&lt;value&gt;\d+)(?&lt;unit&gt;cm|mm)?'</span>)-&gt;match(<span class="hljs-string">'14'</span>)-&gt;first(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(Match $match)</span> </span>{
    $match-&gt;hasGroup(<span class="hljs-string">'value'</span>);  <span class="hljs-comment">// true</span>
    $match-&gt;hasGroup(<span class="hljs-string">'unit'</span>);   <span class="hljs-comment">// true, group exists in pattern</span>
    $match-&gt;hasGroup(<span class="hljs-string">'other'</span>);  <span class="hljs-comment">// false, group doesn't exist in pattern</span>
    
    $match-&gt;matched(<span class="hljs-string">'value'</span>);  <span class="hljs-comment">// true</span>
    $match-&gt;matched(<span class="hljs-string">'unit'</span>);   <span class="hljs-comment">// false, group exists, but was not matched in pattern</span>
    $match-&gt;matched(<span class="hljs-string">'other'</span>);  <span class="hljs-comment">// NonexistentGroupException</span>
});
</code></pre>
<p>It'll work just the same with regular (not named) groups:</p>
<pre><code class="hljs css language-php">pattern(<span class="hljs-string">'(?&lt;value&gt;\d+)(?&lt;unit&gt;cm|mm)'</span>)-&gt;match(<span class="hljs-string">''</span>)-&gt;first(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(Match $match)</span> </span>{
    $match-&gt;hasGroup(<span class="hljs-number">0</span>);  <span class="hljs-comment">// true</span>
    $match-&gt;hasGroup(<span class="hljs-number">1</span>);  <span class="hljs-comment">// true</span>
    $match-&gt;hasGroup(<span class="hljs-number">2</span>);  <span class="hljs-comment">// false</span>
});
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="invalid-groups-and-arguments-1"></a><a href="#invalid-groups-and-arguments-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Invalid groups and arguments</h4>
<ul>
<li><code>hasGroup()</code> will throw <code>\InvalidArgumentException</code>, when used with an invalid group <em>(i.e. <code>2group</code>, <code>-1</code> or any other type than <code>string</code> or <code>int</code>)</em>.</li>
</ul>
<blockquote>
<p>Usages of <code>hasGroup()</code> are rather infrequent, because rarely patterns are dynamic - they're constant much more often; hence the developer doesn't have to check whether the group exists. The pattern is constant - the collection of groups is also constant.</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="composite-groups"></a><a href="#composite-groups" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Composite groups</h2>
<pre><code class="hljs css language-php">$p = <span class="hljs-string">'(?&lt;value&gt;\d+)(?&lt;unit&gt;cm|mm)'</span>;
$s = <span class="hljs-string">'192mm and 168cm or 18mm and 12cm'</span>;

pattern($p)-&gt;match($s)-&gt;forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(Match $match)</span> </span>{ 
    $match-&gt;groups()-&gt;texts();       <span class="hljs-comment">// ['168', 'cm']</span>
    $match-&gt;namedGroups()-&gt;texts();  <span class="hljs-comment">// ['value' =&gt; '168', 'unit' =&gt; 'cm']</span>
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="group-names"></a><a href="#group-names" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Group names</h3>
<p>Method <code>groupNames()</code> returns a simple <code>string[]</code> with names of the capturing groups in order:</p>
<pre><code class="hljs css language-php">pattern(<span class="hljs-string">'(?&lt;value&gt;\d+)(?&lt;unit&gt;cm|mm)'</span>)-&gt;match(<span class="hljs-string">'14cm'</span>)-&gt;first(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(Match $match)</span> </span>{
    $match-&gt;groupNames();    <span class="hljs-comment">// ['value', 'unit']</span>
});
</code></pre>
<p>If there are no named groups, it simply returns an empty array:</p>
<pre><code class="hljs css language-php">pattern(<span class="hljs-string">'(\d+)(cm|mm)'</span>)-&gt;match(<span class="hljs-string">'14cm'</span>)-&gt;first(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(Match $match)</span> </span>{
    $match-&gt;groupNames();    <span class="hljs-comment">// []</span>
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="groups-count"></a><a href="#groups-count" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Groups count</h3>
<p>Method <code>groupsCount()</code> returns a number of the capturing groups (without duplicates of named and regular groups)</p>
<pre><code class="hljs css language-php">pattern(<span class="hljs-string">'(?&lt;value&gt;\d+)(?&lt;unit&gt;cm|mm)'</span>)-&gt;match(<span class="hljs-string">'14cm'</span>)-&gt;first(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(Match $match)</span> </span>{
    $match-&gt;groupsCount();    <span class="hljs-comment">// 2</span>
});
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="other-occurrences"></a><a href="#other-occurrences" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Other occurrences</h2>
<p>Method <code>group()-&gt;all()</code> allows you to get the group from all other matches:</p>
<pre><code class="hljs css language-php">$p = <span class="hljs-string">'(?&lt;value&gt;\d+)(?&lt;unit&gt;cm|mm)'</span>;
$s = <span class="hljs-string">'192mm and 168cm or 18mm and 12cm'</span>;

pattern($p)-&gt;match($s)-&gt;first(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(Match $match)</span> </span>{
    $match-&gt;group(<span class="hljs-string">'value'</span>)-&gt;all();   <span class="hljs-comment">// ['192', '168', '18', '12']</span>
    $match-&gt;group(<span class="hljs-string">'unit'</span>)-&gt;all();    <span class="hljs-comment">// ['mm', 'cm', 'mm', 'cm']</span>
});
</code></pre>
<p>If the group is not matched in other occurrences, its value in <code>all()</code> result array will be <code>null</code>:</p>
<pre><code class="hljs css language-php">$p = <span class="hljs-string">'(?&lt;value&gt;\d+)(?&lt;unit&gt;cm|mm)?'</span>;
$s = <span class="hljs-string">'192mm and 168 or 18mm and 12'</span>;

pattern($p)-&gt;match($s)-&gt;first(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(Match $match)</span> </span>{
    $match-&gt;group(<span class="hljs-string">'value'</span>)-&gt;all();   <span class="hljs-comment">// ['192', '168', '18', '12']</span>
    $match-&gt;group(<span class="hljs-string">'unit'</span>)-&gt;all();    <span class="hljs-comment">// ['mm', null, 'mm', null]</span>
});
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="groups-in-depth"></a><a href="#groups-in-depth" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Groups In-Depth</h2>
<h3><a class="anchor" aria-hidden="true" id="invalid-group-identifiers"></a><a href="#invalid-group-identifiers" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Invalid group identifiers</h3>
<p>In plain, old, vanilla PHP there's no difference between:</p>
<ul>
<li>an invalid group (name <code>2group</code> or index <code>-1</code>)</li>
<li>valid, but non-existent group</li>
<li>existent, but not matched group</li>
<li>matched group, but value is <code>''</code> (empty string)</li>
</ul>
<p>The two first cases always return <code>null</code>, the third one returns either <code>''</code> or <code>null</code> (depending on the <strong>order of groups!</strong>).
If you used <code>PREG_OFFSET_CAPTURE</code>, it'll return <code>['', -1]</code> instead. And of course the last one returns <code>''</code>, which might the same
as the third.</p>
<p>Since PHP 7.2, there's <code>PREG_UNMATCHED_AS_NULL</code> - it's a little better, it allows to distinguish unmatched from matched empty string,
but to distinguish invalid and non-existent groups from unmatched - you have to use <code>array_key_exists()</code>.</p>
<hr>
<p>And T-Regx <strong>hates</strong> it. We <strong>hate</strong> it.</p>
<hr>
<p>That's why T-Regx has 3 separate methods to deal with each of these cases separately. Here's how they work:</p>
<table>
<thead>
<tr><th>Group</th><th>Invalid</th><th>Non-existent</th><th>Not matched</th><th>Matched</th></tr>
</thead>
<tbody>
<tr><td><code>hasGroup()</code></td><td><code>InvalidArgument</code></td><td><code>false</code></td><td><code>true</code></td><td><code>true</code></td></tr>
<tr><td><code>matched()</code></td><td><code>InvalidArgument</code></td><td><code>NonexistentGroup</code></td><td><code>false</code></td><td><code>true</code></td></tr>
<tr><td><code>text()</code></td><td><code>InvalidArgument</code></td><td><code>NonexistentGroup</code></td><td><code>GroupNotMatched</code></td><td>Value of the group</td></tr>
</tbody>
</table>
<p>In short:</p>
<ul>
<li>You can't use an invalid group (<code>2startingWithDigit</code> or negative <code>-1</code>)</li>
<li>You can't use a non-existent method (except with <code>hasGroup()</code>)</li>
<li>You can't use a non-matched group (except with <code>hasGroup()</code> and with <code>matched()</code>)</li>
</ul>
<blockquote>
<ul>
<li><code>InvalidArgument</code> is <code>\InvalidArgumentException</code></li>
<li><code>NonexistentGroup</code> is <code>NonexistentGroupException</code></li>
<li><code>GroupNotMatched</code> is <code>GroupNotMatchedException</code></li>
</ul>
</blockquote>
</span></div></article></div><div class="docLastUpdate"><em>Last updated on 2019-7-10</em></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/match-details"><span class="arrow-prev">← </span><span>Match details</span></a><a class="docs-next button" href="/docs/match-offsets"><span>Match offsets</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#overview">Overview</a></li><li><a href="#group-details">Group details</a><ul class="toc-headings"><li><a href="#offsets">Offsets</a></li><li><a href="#optional-groups">Optional groups</a></li><li><a href="#index-name-and-identifier">Index, name and identifier</a></li></ul></li><li><a href="#group-is-matched">Group is matched</a></li><li><a href="#group-exists">Group exists</a></li><li><a href="#composite-groups">Composite groups</a><ul class="toc-headings"><li><a href="#group-names">Group names</a></li><li><a href="#groups-count">Groups count</a></li></ul></li><li><a href="#other-occurrences">Other occurrences</a></li><li><a href="#groups-in-depth">Groups In-Depth</a><ul class="toc-headings"><li><a href="#invalid-group-identifiers">Invalid group identifiers</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/t.regx.png" alt="T-Regx" width="64" height="52"/></a><div><h5>Docs</h5><a href="/docs/installation">Installation</a><a href="/docs/introduction">Getting Started</a><a href="/docs/match">Documentation</a><a href="https://github.com/T-Regx/T-Regx/blob/master/ChangeLog.md#api">API Reference</a></div><div><h5>More</h5><a href="/blog">Blog</a><a href="https://github.com/T-Regx/T-Regx" target="_blank">GitHub</a><a class="github-button" href="https://github.com/T-Regx/T-Regx" title="See this project on GitHub" data-icon="octicon-star" data-show-count="true" data-count-href="/T-Regx/T-Regx/stargazers" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">T-Regx</a></div></section><section class="copyright">Copyright © 2017-2019 Daniel Wilkowski</section><section class="sitemap discussion-section"><div><div>
<script>
    (function () {
       if (typeof window.disqus_shortname !== 'undefined') {
            return;
        }
        window.disqus_shortname = 't-regx';
        window.disqus_identifier = '46dff8e37535ddb3571510672d1af48683bad013';
        window.disqus_title = 'Questions about T-Regx';
        window.disqus_url = 'http://localhost:3000/help';
        if (window.DISQUS === undefined) {
            const script = document.createElement('script');
            script.async = true;
            script.src = 'https://t-regx.disqus.com/embed.js';
            document.getElementsByTagName('head')[0].appendChild(script);
        } else {
            window.DISQUS.reset({reload: true});
        }
    })();
</script></div><div id="disqus_thread"></div></div></section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '6d3eef6432e87213c7f031ee898b73a1',
                indexName: 't-regx',
                inputSelector: '#search_input_react',
                algoliaOptions: {}
              });
            </script></body></html>