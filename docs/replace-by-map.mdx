---
id: replace-by-map
title: Replace by map
---

import {CodeTabs, Result} from './code';

There are cases when you have to use more than one replacement, but you also don't need [`Match`](match-details.md) details or
any replacement logic, really, so both `with()` and `callback()` are a little unfit.

Replacing by map allows T-Regx to save a little performance overhead, by not creating [`Match`](match-details.md) object.

## Standard map

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<CodeTabs
    tregx={`$message = 'My words: "mp3", "mp4", "gif"';\n
pattern('\\b\\w{3}\\b')->replace($message)->all()->by()->map([
    'mp3' => 'Audio file',
    'mp4' => 'Video file',
    'gif' => 'Animation'
]);`}
    php={`$message = 'My words: "mp3", "mp4", "gif"';\n
preg::replace_callback('/\\b\\w{3}\\b/', function ($match) {
    $map = [
        'mp3' => 'Audio file',
        'mp4' => 'Video file',
        'gif' => 'Animation'
    ];
    if (!array_key_exists($match[0], $map)) {
        throw new MissingReplacementKeyException();
    }
    $result = $map[$match[0]];
    if (!is_string($result)) {
        throw new InvalidArgumentException();
    }
    return $result;
}, $message);`}/>

<!--T-Regx:{echo-at(2)}-->
<!--PHP:{echo-at(2)}-->
<Result>My words: "Audio file", "Video file", "Animation"</Result>

And of course `all()`/`first()`/`only(int)` modifiers are taken into account.

### Superfluous matches

Normally, had you found a match that's not present in your map - `MissingReplacementKeyException` would be thrown
(as long as `gif` is matched by your pattern, of course):

```php
$message = 'My words: "mp3", "mp4", "gif"';

pattern('\w{3}')->replace($message)->all()->by()->map([
   'mp3'   => 'Audio file',
   'mp4'   => 'Video file'
  // 'gif'  => 'Animation'
]);
```

If you don't need to specify all your possible `[match => replacement]` pairs, you should use one of the below `mapIfExists()`.

### Ignored replacements

With `mapIfExists()` - superfluous occurrences are left unchanged:

<CodeTabs
    tregx={`$message = "Extensions: mp3, mp4, jpg, jpeg, png, gif";\n
pattern('\\b\\w{3,4}\\b')->replace($message)->all()->by()->mapIfExists([
   'mp3' => 'Audio',
   'gif' => 'Animation'
]);`}
    php={`$message = "Extensions: mp3, mp4, jpg, jpeg, png, gif";\n
preg::replace_callback('/\\b\\w{3}\\b/', function ($match) {
    $map = [
        'mp3' => 'Audio',
        'gif' => 'Animation'
    ];
    if (!array_key_exists($match[0], $map)) {
        return $match[0];
    }
    $result = $map[$match[0]];
    if (!is_string($result)) {
        throw new InvalidArgumentException();
    }
    return $result;
}, $message);`}/>

<!--T-Regx:{echo-at(2)}-->
<!--PHP:{echo-at(2)}-->
<Result>Extensions: Audio, mp4, jpg, jpeg, png, Animation</Result>

## Groups

Resolving a replacement based on a **whole match** however, is both uncommon and unpractical. It's much more elastic to resolve
it based on a specific capturing group, using `by()->group()->map()`:

<CodeTabs
    tregx={`$links = 'Links: www.google.com, http://socket.io, facebook.com, https://t-regx.com';\n
pattern('(https?://)?(www\\.)?(?<domain>[\\w-]+)\\.(com|io)')
    ->replace($links)
    ->all()
    ->by()
    ->group('domain')
    ->map([
       'google'   => 'Search Engine',
       'socket'   => 'Documentation',
       'facebook' => 'Social Portal',
       't-regx'   => 'Documentation',
    ])
    ->orThrow();`}
    php={`$links = 'Links: www.google.com, http://socket.io, facebook.com, https://t-regx.com';\n
preg::replace_callback('#(https?://)?(www\\.)?(?<domain>[\\w-]+)\\.(com|io)#', function (array $match) {
    // possible invalid group, e.g. "2group" or -2
    validateGroupName('domain');\n
    $group = $match['domain'];
    if (!array_key_exists('domain', $match)) {
        // group is either un-matched or non-existent
        if (validateGroupExists('domain', $match)) {
            $group = $match['domain'];
        } else {
            throw new NonexistentGroupException('domain');
        }
    }
    if ($match['domain'] === '') {
        // group is either un-matched or matched an empty string
        if (validateGroupMatched('domain', $match)) {
            $group = $match['domain'];
        } else {
            throw new GroupNotMatchedException();
        }
    }\n
    $map = [
        'google'   => 'Search Engine',
        'socket'   => 'Documentation',
        'facebook' => 'Social Portal',
        't-regx'   => 'Documentation',
    ];
    if (!array_key_exists($group, $map)) {
        throw new MissingReplacementKeyException();
    }
    $result = $map[$group];
    if (!is_string($result)) {
        throw new InvalidArgumentException();
    }
    return $result;
}, $links);`}/>

<!--T-Regx:{echo-at(2)}-->
<!--PHP:{echo-at(2)}-->
<Result>Links: Search Engine, Documentation, Social Portal, Documentation</Result>
