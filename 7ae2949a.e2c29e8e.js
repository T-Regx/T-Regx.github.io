(window.webpackJsonp=window.webpackJsonp||[]).push([[52],{117:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"metadata",(function(){return l})),n.d(t,"rightToc",(function(){return c})),n.d(t,"default",(function(){return b}));var r=n(2),a=n(6),i=(n(0),n(180)),o={id:"introduction-safe",title:"Start with SafeRegex"},l={unversionedId:"introduction-safe",id:"introduction-safe",isDocsHomePage:!1,title:"Start with SafeRegex",description:"Here are the absolute basics you need to get familiar with, before we can learn T-Regx.",source:"@site/../docs/introduction-safe.md",slug:"/introduction-safe",permalink:"/docs/introduction-safe",version:"current",lastUpdatedAt:1604751680,sidebar:"docs",previous:{title:"Installation",permalink:"/docs/installation"},next:{title:"Migrate to T-Regx",permalink:"/docs/introduction-clean"}},c=[{value:"Overview - T-Regx duality",id:"overview---t-regx-duality",children:[]},{value:"About SafeRegex",id:"about-saferegex",children:[]},{value:"What does SafeRegex do",id:"what-does-saferegex-do",children:[]},{value:"Mix and match",id:"mix-and-match",children:[]},{value:"Word about exceptions",id:"word-about-exceptions",children:[]},{value:"Final words",id:"final-words",children:[]}],p={rightToc:c};function b(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(i.b)("wrapper",Object(r.a)({},p,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,"Here are the absolute basics you need to get familiar with, before we can learn T-Regx."),Object(i.b)("h2",{id:"overview---t-regx-duality"},"Overview - T-Regx duality"),Object(i.b)("p",null,"When you add T-Regx to your project, you can actually choose the API, with which you are most comfortable."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"SafeRegex")," - the wrapper on PCRE (making the ",Object(i.b)("inlineCode",{parentName:"li"},"preg_")," methods throw exceptions)."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"CleanRegex")," - the higher-level API, build on top of ",Object(i.b)("inlineCode",{parentName:"li"},"SafeRegex"),".")),Object(i.b)("p",null,"You can work with either or both them in your project - they're both part of T-Regx."),Object(i.b)("p",null,"We suggest, after installing T-Regx, to use SafeRegex everywhere you can (to protect yourself against obvious errors),\nand then gradually migrate from ",Object(i.b)("inlineCode",{parentName:"p"},"preg::")," (SafeRegex) to ",Object(i.b)("inlineCode",{parentName:"p"},"pattern()")," (CleanRegex)."),Object(i.b)("h2",{id:"about-saferegex"},"About SafeRegex"),Object(i.b)("p",null,"With SafeRegex, you can safely replace every ",Object(i.b)("inlineCode",{parentName:"p"},"preg_")," method with ",Object(i.b)("inlineCode",{parentName:"p"},"preg::"),". It handles ",Object(i.b)("strong",{parentName:"p"},"any possible")," ",Object(i.b)("inlineCode",{parentName:"p"},"preg_"),"\nerror:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"runtime errors (malformed subject, malformed utf8), ",Object(i.b)("inlineCode",{parentName:"li"},"preg_last_error()")," codes."),Object(i.b)("li",{parentName:"ul"},"preg compile errors, preg syntax errors, warnings/notices with ",Object(i.b)("inlineCode",{parentName:"li"},"error_get_last()"),"."),Object(i.b)("li",{parentName:"ul"},"invalid input arguments, invalid callback return values."),Object(i.b)("li",{parentName:"ul"},"Additionally, sometimes certain arguments  (like ",Object(i.b)("inlineCode",{parentName:"li"},"false"),", ",Object(i.b)("inlineCode",{parentName:"li"},"null"),") or other unexpected parameters cause ",Object(i.b)("inlineCode",{parentName:"li"},"preg_")," to misbehave in strange ways. In those cases, SafeRegex also throws exceptions. "),Object(i.b)("li",{parentName:"ul"},"Some arguments cause ",Object(i.b)("inlineCode",{parentName:"li"},"preg_")," methods to throw fatal errors. SafeRegex handles them as well with a proper exception,\npreventing fatal errors.")),Object(i.b)("p",null,"Anything! If something's not right with ",Object(i.b)("inlineCode",{parentName:"p"},"preg_")," - SafeRegex will throw a proper exception, you can be sure of that). "),Object(i.b)("p",null,"You should replace this code in your project:"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-php"}),'// highlight-next-line\nif (($result = preg_match(\'/^foo:\\d+$\', $string, $match)) !== false) {\n  if ($result) {\n    return $match[0];\n  }\n  return "no match";\n} else {\n    switch (preg_last_error()) {\n      case PREG_BAD_UTF8_ERROR:\n        return "utf8 error";\n      case PREG_BAD_UTF8_OFFSET_ERROR:\n        return "utf8 offset error";\n      case PREG_BACKTRACK_LIMIT_ERROR:\n        return "optimize your pattern";\n      case PREG_RECURSION_LIMIT_ERROR:\n        return "went a little too far, buddy";\n    }   \n}\n')),Object(i.b)("p",null,"...with SafeRegex methods (which never return ",Object(i.b)("inlineCode",{parentName:"p"},"false"),"/",Object(i.b)("inlineCode",{parentName:"p"},"null")," and map errors to exceptions):"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-php"}),'use \\TRegx\\SafeRegex\\preg;\n\ntry {\n  // highlight-next-line\n  if (preg::match(\'/^foo:\\d+$\', $string, $match)) {\n    return $match[0];\n  }\n  return "no match";\n} \ncatch (SubjectEncodingPregException $exception) {\n  return "utf8 error";\n}\ncatch (Utf8OffsetPregException $exception) {\n  return "utf8 offset error";\n}\ncatch (CatastrophicBacktrackingPregException $exception) {\n  return "optimize your pattern";\n}\ncatch (RecursionLimitPregException $exception) {\n  return "went a little too far, buddy";\n}\ncatch (MalformedPatternException $exception) {\n  return "your pattern has a syntax error";\n  // this one is actually impossible to catch with traditional methods,\n  // but with T-Regx it\'s just as easy as any other \n}\n')),Object(i.b)("p",null,"or just :)"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-php"}),'try {\n  // highlight-next-line\n  if (preg::match(\'/^foo:\\d+$\', $string, $match)) {\n    return $match[0];\n  }\n  return "no match";\n} \ncatch (PregException $exception) {\n  return "any kind of error, literally anything";\n}\n')),Object(i.b)("p",null,"You don't need ",Object(i.b)("inlineCode",{parentName:"p"},"!== false")," anymore, because ",Object(i.b)("inlineCode",{parentName:"p"},"preg::match()")," never returns error-indicating values like\n",Object(i.b)("inlineCode",{parentName:"p"},"false"),", ",Object(i.b)("inlineCode",{parentName:"p"},"null"),", ",Object(i.b)("inlineCode",{parentName:"p"},'""')," or ",Object(i.b)("inlineCode",{parentName:"p"},"-1"),". Proper exception is throw in case of an error."),Object(i.b)("p",null,"You don't need to call ",Object(i.b)("inlineCode",{parentName:"p"},"preg_last_error()")," either, because in case of runtime errors/warnings, ",Object(i.b)("inlineCode",{parentName:"p"},"preg::")," throws\nproper exceptions as well!"),Object(i.b)("p",null,"Each ",Object(i.b)("inlineCode",{parentName:"p"},"preg_")," method (like ",Object(i.b)("inlineCode",{parentName:"p"},"preg_replace()"),", ",Object(i.b)("inlineCode",{parentName:"p"},"preg_split()"),") has its own SafeRegex wrapper (e.g. ",Object(i.b)("inlineCode",{parentName:"p"},"preg::replace()"),", ",Object(i.b)("inlineCode",{parentName:"p"},"preg::split()"),", etc.)."),Object(i.b)("h2",{id:"what-does-saferegex-do"},"What does SafeRegex do"),Object(i.b)("p",null,"In fact, you should replace every ",Object(i.b)("inlineCode",{parentName:"p"},"preg_match()")," with ",Object(i.b)("inlineCode",{parentName:"p"},"preg::match()"),", ",Object(i.b)("inlineCode",{parentName:"p"},"preg_replace()"),"\nwith ",Object(i.b)("inlineCode",{parentName:"p"},"preg::replace()"),", right away! It's very safe, since their APIs are exactly the same."),Object(i.b)("p",null,"SafeRegex (",Object(i.b)("inlineCode",{parentName:"p"},"preg::")," methods) is an exact copy of ",Object(i.b)("inlineCode",{parentName:"p"},"preg_")," methods, but with additional safety features built-in."),Object(i.b)("p",null,"Most importantly:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"On error, ",Object(i.b)("inlineCode",{parentName:"li"},"preg_match()")," would return ",Object(i.b)("inlineCode",{parentName:"li"},"false"),", and you need to use ",Object(i.b)("inlineCode",{parentName:"li"},"preg_last_error()")," to see the error code.\n",Object(i.b)("inlineCode",{parentName:"li"},"preg::match()"),", on the other hand, will throw a proper exception, depending on the nature of the error."),Object(i.b)("li",{parentName:"ul"},"When building a pattern, PHP would raise a compile-time warning/error, which is impossible to try/catch or react to.\nSafeRegex will just throw ",Object(i.b)("inlineCode",{parentName:"li"},"MalformedPatternException"),"."),Object(i.b)("li",{parentName:"ul"},"When passing invalid arguments (",Object(i.b)("inlineCode",{parentName:"li"},"null"),", ",Object(i.b)("inlineCode",{parentName:"li"},"[]"),", objects) by accident into some PCRE methods, you might actually\ncause a fatal error, that terminates the application. ",Object(i.b)("inlineCode",{parentName:"li"},"preg::")," methods in any of those case will just throw\n",Object(i.b)("inlineCode",{parentName:"li"},"InvalidReturnValueException"),"."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"preg_quote()")," quotes different characters on different PHP versions, whereas ",Object(i.b)("inlineCode",{parentName:"li"},"preg::quote()")," works consistently everywhere."),Object(i.b)("li",{parentName:"ul"},"Most of ",Object(i.b)("inlineCode",{parentName:"li"},"preg_()")," methods ignore invalid arguments, ",Object(i.b)("inlineCode",{parentName:"li"},"preg::()")," methods throw ",Object(i.b)("a",Object(r.a)({parentName:"li"},{href:"https://www.php.net/manual/en/class.invalidargumentexception.php"}),Object(i.b)("inlineCode",{parentName:"a"},"\\InvalidArgumentException"))," in that case.")),Object(i.b)("p",null,"There are other safety features added by SafeRegex, like PHP bug fixes."),Object(i.b)("h2",{id:"mix-and-match"},"Mix and match"),Object(i.b)("p",null,"In Vanilla-PHP, if you mix and match multiple calls to ",Object(i.b)("inlineCode",{parentName:"p"},"preg")," methods, like maybe calling ",Object(i.b)("inlineCode",{parentName:"p"},"preg_match()"),",\n",Object(i.b)("inlineCode",{parentName:"p"},"preg_replace()"),", and ",Object(i.b)("inlineCode",{parentName:"p"},"preg_split()")," right after each other, it may be really difficult to figure out\nwhich method was prone to error. "),Object(i.b)("p",null,"SafeRegex can always narrow down the error to the exact method to one particular call (even nested ones,\nlike malformed preg call inside ",Object(i.b)("inlineCode",{parentName:"p"},"preg_replace_callback()"),"):"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-php"}),"preg::replace_callback('pattern', function ($match) {  // this method won't throw exception\n    try {\n        return preg::replace_callback('({%invalid', 'strlen', '');  // this will throw exception\n    } catch (PregException $e) {\n        return '';  // it will be handled\n    }\n}, $subject); \n")),Object(i.b)("p",null,"Basically, SafeRegex can isolate the preg call to one method. "),Object(i.b)("p",null,"But don't worry! T-Regx doesn't touch ",Object(i.b)("inlineCode",{parentName:"p"},"set_error_handler()")," nor ",Object(i.b)("inlineCode",{parentName:"p"},"set_exception_handler()"),", you can be sure of that! :)"),Object(i.b)("h2",{id:"word-about-exceptions"},"Word about exceptions"),Object(i.b)("p",null,"When using ",Object(i.b)("inlineCode",{parentName:"p"},"preg::...()")," methods, any error-prone situation is handled with an exception. Not only will it\ngive you insight about the nature of the error (",Object(i.b)("inlineCode",{parentName:"p"},"MalformedPattern"),", ",Object(i.b)("inlineCode",{parentName:"p"},"CatastrophicBacktracking"),", utf8 exceptions),\nit will allow you to get even more details with the methods on the exception:"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{}),"try {\n    preg::match('/(foo/', 'foo');\n} catch (PregException $exception) {\n    $exception->getInvokingMethod();  // 'preg_match'\n    $exception->getPregPattern();     // '/(foo/' \n}\n")),Object(i.b)("h2",{id:"final-words"},"Final words"),Object(i.b)("p",null,"That's it about SafeRegex! Really!"),Object(i.b)("p",null,"SafeRegex method names, arguments, return types are exactly the same as vanilla PHP ",Object(i.b)("inlineCode",{parentName:"p"},"preg_")," methods, so you only\nneed to change ",Object(i.b)("inlineCode",{parentName:"p"},"preg_")," to ",Object(i.b)("inlineCode",{parentName:"p"},"preg::")," and you're already protected against every compile-time or runtime warning/error/notice, magic value and other code-smells\npresent in PCRE. Every callback, flag, argument is copied 1:1. In terms of programming usage - they're identical. The\nonly difference is ",Object(i.b)("inlineCode",{parentName:"p"},"preg::")," instead of ",Object(i.b)("inlineCode",{parentName:"p"},"preg_"),"."),Object(i.b)("p",null,"In the next chapters, we'll talk about CleanRegex - the higher level API solving more complicated problems of\nPHP regular expressions, other than the complete lack of exceptions."))}b.isMDXComponent=!0},180:function(e,t,n){"use strict";n.d(t,"a",(function(){return s})),n.d(t,"b",(function(){return m}));var r=n(0),a=n.n(r);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var p=a.a.createContext({}),b=function(e){var t=a.a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},s=function(e){var t=b(e.components);return a.a.createElement(p.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},d=a.a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,p=c(e,["components","mdxType","originalType","parentName"]),s=b(n),d=r,m=s["".concat(o,".").concat(d)]||s[d]||u[d]||i;return n?a.a.createElement(m,l(l({ref:t},p),{},{components:n})):a.a.createElement(m,l({ref:t},p))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=d;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var p=2;p<i;p++)o[p]=n[p];return a.a.createElement.apply(null,o)}return a.a.createElement.apply(null,n)}d.displayName="MDXCreateElement"}}]);