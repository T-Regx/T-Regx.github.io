(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{208:function(e,t,a){"use strict";var n=a(0),i=a.n(n),l=a(210),r=a.n(l);t.a=function(e){const{block:t,children:a,defaultValue:l,values:c}=e,[b,s]=Object(n.useState)(l);return i.a.createElement("div",null,i.a.createElement("ul",{className:r()("tabs",{"tabs--block":t})},c.map(({value:e,label:t})=>i.a.createElement("li",{className:r()("tab-item",{"tab-item--active":b===e}),key:e,onClick:()=>s(e)},t))),i.a.createElement("div",{className:"margin-vert--md"},n.Children.toArray(a).filter(e=>e.props.value===b)[0]))}},209:function(e,t,a){"use strict";var n=a(0),i=a.n(n);t.a=function(e){return i.a.createElement("div",null,e.children)}},95:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return c})),a.d(t,"rightToc",(function(){return b})),a.d(t,"default",(function(){return d}));a(211);var n=a(207),i=a(208),l=a(209);function r(){return(r=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var a=arguments[t];for(var n in a)Object.prototype.hasOwnProperty.call(a,n)&&(e[n]=a[n])}return e}).apply(this,arguments)}const c={id:"delimiters",title:"Automatic delimiters"},b=[{value:"Is pattern delimited",id:"is-pattern-delimited",children:[]},{value:"Adding delimiters",id:"adding-delimiters",children:[{value:"Ambiguity",id:"ambiguity",children:[]}]},{value:"Flags",id:"flags",children:[]},{value:"I want to break it",id:"i-want-to-break-it",children:[]}],s={rightToc:b},p="wrapper";function d({components:e,...t}){return Object(n.b)(p,r({},s,t,{components:e,mdxType:"MDXLayout"}),Object(n.b)("blockquote",null,Object(n.b)("p",{parentName:"blockquote"},"This chapter doesn't contain ",Object(n.b)("inlineCode",{parentName:"p"},"PHP")," code snippets, because PHP PCRE require delimiters. There is no way to omit them\nin Vanilla PHP.")),Object(n.b)("p",null,"Thanks to automatic delimiters, one can use regular expressions without ",Object(n.b)("a",r({parentName:"p"},{href:"/docs/overview#brain-strain"}),"brain strain"),"\nand without coming up with a suitable delimiter."),Object(n.b)("pre",null,Object(n.b)("code",r({parentName:"pre"},{className:"language-php"}),"pattern('[A-Z][a-z]+')->match($subject)->first();\n")),Object(n.b)("p",null,"Automatic delimiters work perfectly fine, regardless of whether you passed a delimited pattern or not."),Object(n.b)("pre",null,Object(n.b)("code",r({parentName:"pre"},{className:"language-php"}),"pattern('[A-Z][a-z]+')->match($subject)->first();\npattern('#[A-Z][a-z]+#')->match($subject)->first();\n")),Object(n.b)("p",null,"The code snippets above are equal."),Object(n.b)("h2",{id:"is-pattern-delimited"},"Is pattern delimited"),Object(n.b)("p",null,"You can check whether a pattern is delimited with ",Object(n.b)("inlineCode",{parentName:"p"},"is()->delimited()")," method."),Object(n.b)(i.a,{defaultValue:"T-Regx",values:[{label:"T-Regx",value:"T-Regx"}],mdxType:"Tabs"},Object(n.b)(l.a,{value:"T-Regx",mdxType:"TabItem"},Object(n.b)("pre",null,Object(n.b)("code",r({parentName:"pre"},{className:"language-php"}),"pattern('[A-Z][a-z]+')->is()->delimitered();\npattern('#[A-Z][a-z]+#')->is()->delimitered();\n")))),Object(n.b)("div",{className:"output-block"},Object(n.b)("pre",null,Object(n.b)("code",r({parentName:"pre"},{className:"language-php"}),"false\ntrue\n"))),Object(n.b)("h2",{id:"adding-delimiters"},"Adding delimiters"),Object(n.b)("p",null,"To change undelimited pattern into a delimited one - use ",Object(n.b)("inlineCode",{parentName:"p"},"delimiter()")," method;"),Object(n.b)(i.a,{defaultValue:"T-Regx",values:[{label:"T-Regx",value:"T-Regx"}],mdxType:"Tabs"},Object(n.b)(l.a,{value:"T-Regx",mdxType:"TabItem"},Object(n.b)("pre",null,Object(n.b)("code",r({parentName:"pre"},{className:"language-php"}),"pattern('Welcome/Or not')->delimiter();\n")))),Object(n.b)("div",{className:"output-block"},Object(n.b)("pre",null,Object(n.b)("code",r({parentName:"pre"},{className:"language-text"}),"#Welcome/Or not#\n"))),Object(n.b)("h3",{id:"ambiguity"},"Ambiguity"),Object(n.b)("p",null,"How does T-Regx decide whether a pattern is already delimited, or whether it's not and needs to be delimited again?"),Object(n.b)("p",null,"The rule is simple."),Object(n.b)("p",null,"If a pattern ",Object(n.b)("em",{parentName:"p"},"can")," be thought of as delimited - T-Regx assumes it's delimited."),Object(n.b)("h2",{id:"flags"},"Flags"),Object(n.b)("p",null,"There are two ways of passing flags:"),Object(n.b)("p",null,"Either pass a second argument to the ",Object(n.b)("a",r({parentName:"p"},{href:"/docs/introduction#entry-points"}),Object(n.b)("inlineCode",{parentName:"a"},"pattern()")),"/",Object(n.b)("a",r({parentName:"p"},{href:"/docs/introduction#entry-points"}),Object(n.b)("inlineCode",{parentName:"a"},"Pattern::of()")),":"),Object(n.b)("pre",null,Object(n.b)("code",r({parentName:"pre"},{className:"language-php"}),"pattern('[A-Z][a-z]+', 'i')->match($subject)->first();\n")),Object(n.b)("p",null,"or use a regular delimited pattern with a flag:"),Object(n.b)("pre",null,Object(n.b)("code",r({parentName:"pre"},{className:"language-php"}),"pattern('/[A-Z][a-z]+/i')->match($subject)->first();\n")),Object(n.b)("h2",{id:"i-want-to-break-it"},"I want to break it"),Object(n.b)("p",null,"T-Regx has a set of predefined, suitable delimiters (like ",Object(n.b)("inlineCode",{parentName:"p"},"/"),", ",Object(n.b)("inlineCode",{parentName:"p"},"#"),", ",Object(n.b)("inlineCode",{parentName:"p"},"~"),", etc.) and simply uses the first one,\nthat doesn't occur in your pattern. If you exhaust each of them; if you use every possible, predefined, suitable delimiter -\nT-Regx will throw ",Object(n.b)("inlineCode",{parentName:"p"},"ExplicitDelimiterRequiredException"),"."),Object(n.b)("p",null,"In that case, you simply have to use an explicit, regular delimiter and automatic delimiter won't be used."),Object(n.b)("p",null,"If you think another automatic delimiter can be used,\nplease create ",Object(n.b)("a",r({parentName:"p"},{href:"https://github.com/T-Regx/T-Regx/issues/new/choose"}),"a github issue"),"."))}d.isMDXComponent=!0}}]);