(window.webpackJsonp=window.webpackJsonp||[]).push([[53],{118:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"metadata",(function(){return p})),n.d(t,"rightToc",(function(){return l})),n.d(t,"default",(function(){return b}));var a=n(2),r=n(6),i=(n(0),n(179)),o={id:"match-groups-j-modifier",title:"Capturing groups - J modifier"},p={unversionedId:"match-groups-j-modifier",id:"match-groups-j-modifier",isDocsHomePage:!1,title:"Capturing groups - J modifier",description:"Overview",source:"@site/../docs/match-groups-j-modifier.md",slug:"/match-groups-j-modifier",permalink:"/docs/match-groups-j-modifier",version:"current",lastUpdatedAt:1610570386,sidebar:"docs",previous:{title:"Capturing groups - in depth",permalink:"/docs/match-groups-in-depth"},next:{title:"Advanced replace details",permalink:"/docs/replace-match-details"}},l=[{value:"Overview",id:"overview",children:[]},{value:"The complication",id:"the-complication",children:[]},{value:"The PHP solution",id:"the-php-solution",children:[]},{value:"T-Regx solution",id:"t-regx-solution",children:[]}],c={rightToc:l};function b(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(i.b)("wrapper",Object(a.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("h3",{id:"overview"},"Overview"),Object(i.b)("p",null,"PCRE in PHP offers ",Object(i.b)("inlineCode",{parentName:"p"},"J")," modifier. It can be used either as a flag: ",Object(i.b)("inlineCode",{parentName:"p"},"/foo/J")," (since PHP 7.2),\nor as an in-pattern modifier: ",Object(i.b)("inlineCode",{parentName:"p"},"/foo(?J)/"),"."),Object(i.b)("p",null,"Normally, duplicated pattern names aren't allowed, and such code"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),"pattern('(?<group>)(?<group>)')  // MalformedPatternException\n")),Object(i.b)("p",null,"would throw ",Object(i.b)("inlineCode",{parentName:"p"},"MalformedPatternException"),", with message ",Object(i.b)("inlineCode",{parentName:"p"},"Two named subpatterns have the same name"),"."),Object(i.b)("p",null,"However, ",Object(i.b)("inlineCode",{parentName:"p"},"J")," modifier removes that restriction, and it becomes possible to use duplicated group names\nin one pattern:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),"pattern('(?<group>)(?<group>)', 'J')  // works fine\n")),Object(i.b)("p",null,"It doesn't make much sense for two completely separate groups; it rather may have ",Object(i.b)("em",{parentName:"p"},"some")," sense to be\nused with optional, mutually exclusive groups, like:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),"pattern('((?<scheme>http)|(?<scheme>ftp))', 'J')  // either one or the other\n")),Object(i.b)("p",null,"maybe. T-Regx doesn't encourage such patterns, we'd recommend using one enclosing group for that purpose."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),"pattern('(?<scheme>http|ftp)', 'J')\n")),Object(i.b)("h3",{id:"the-complication"},"The complication"),Object(i.b)("p",null,"PCRE PHP API returns groups as an ",Object(i.b)("inlineCode",{parentName:"p"},"array"),", and PHP arrays can't have duplicate keys. That means, despite\nmultiple groups with the same name being matched, only one will be present in the resulting ",Object(i.b)("inlineCode",{parentName:"p"},"array"),".\nThere are some constants, allowing us to handle the duplicate groups in ",Object(i.b)("em",{parentName:"p"},"some")," way, but it's not perfect."),Object(i.b)("p",null,"That means, T-Regx ",Object(i.b)("strong",{parentName:"p"},"isn't able")," to reliably:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"assign an index to a named group"),Object(i.b)("li",{parentName:"ul"},"assign a name to an indexed group"),Object(i.b)("li",{parentName:"ul"},"determine which of groups are matched or not.")),Object(i.b)("h3",{id:"the-php-solution"},"The PHP solution"),Object(i.b)("p",null,"The solution is far from perfect, but it's PHP, so what can we do :)"),Object(i.b)("p",null,"DN - doubly-named"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"We can't reliably assign a duplicated name to an index, and an index to a name:"),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"group('group')->index()")," returns the index of the ",Object(i.b)("strong",{parentName:"li"},"left-most")," DN group."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"group(2)->name()")," returns the name, only if ",Object(i.b)("inlineCode",{parentName:"li"},"2")," is the index of the ",Object(i.b)("strong",{parentName:"li"},"left-most")," DN group.")),Object(i.b)("p",{parentName:"li"},"So with PHP we assume the ",Object(i.b)("strong",{parentName:"p"},"left-most")," indexed group has the name.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"We can't reliably handle optional DN groups."),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"So, the whole DN is considered unmatched if, and only if the ",Object(i.b)("strong",{parentName:"li"},"right-most")," DN group is not matched."),Object(i.b)("li",{parentName:"ul"},"The ",Object(i.b)("inlineCode",{parentName:"li"},"text()")," and ",Object(i.b)("inlineCode",{parentName:"li"},"offset()")," od the whole DN value, is the text and offset of the ",Object(i.b)("strong",{parentName:"li"},"right-most")," DN group.")))),Object(i.b)("p",null,"Basically:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Index/name relation, is taken from the ",Object(i.b)("strong",{parentName:"p"},"left-most group")),Object(i.b)("p",{parentName:"li"},"And in consequence: ",Object(i.b)("inlineCode",{parentName:"p"},"groupNames()"),", ",Object(i.b)("inlineCode",{parentName:"p"},"namedGroups()"),", etc.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Text/offset/matched is taken from the ",Object(i.b)("strong",{parentName:"p"},"right-most group"),"."),Object(i.b)("p",{parentName:"li"},"And in consequence: ",Object(i.b)("inlineCode",{parentName:"p"},"byteOffset()"),", ",Object(i.b)("inlineCode",{parentName:"p"},"orReturn()"),"/",Object(i.b)("inlineCode",{parentName:"p"},"orElse()"),", ",Object(i.b)("inlineCode",{parentName:"p"},"tail()"),", etc."))),Object(i.b)("p",null,"So basically what a group is, what is its name, order and index is determined by the matched subject. Great :|"),Object(i.b)("h3",{id:"t-regx-solution"},"T-Regx solution"),Object(i.b)("p",null,"The solution we came up with offers predictability and reliability."),Object(i.b)("p",null,"Previously, ",Object(i.b)("inlineCode",{parentName:"p"},"group('name')")," would just read a group by name from the ",Object(i.b)("inlineCode",{parentName:"p"},"$match")," returned by PHP. We can't do it\nanymore, since if ",Object(i.b)("inlineCode",{parentName:"p"},"J")," modifier was used, the index and the order of the group would vary based on the\nmatched occurrence (another gotcha)."),Object(i.b)("p",null,"So first, T-Regx assigns ",Object(i.b)("inlineCode",{parentName:"p"},"'name'")," to an index, and then reads the group. It gives us the advantage of the named\ngroup ",Object(i.b)("strong",{parentName:"p"},"always")," is in the same place (same order) and has exactly the same index. Unfortunately, to read that, we\nalways read the first group used in pattern (but at least its not so stupidly random, as with PHP)."),Object(i.b)("p",null,"All methods that handle capturing groups (",Object(i.b)("inlineCode",{parentName:"p"},"group()"),", ",Object(i.b)("inlineCode",{parentName:"p"},"groups()"),", inline ",Object(i.b)("inlineCode",{parentName:"p"},"group()"),", ",Object(i.b)("inlineCode",{parentName:"p"},"namedGroups()"),", etc.) always\nuse that strategy, and basically they ignore ",Object(i.b)("inlineCode",{parentName:"p"},"J")," modifier, as if it was never used."),Object(i.b)("p",null,"To take advantage of ",Object(i.b)("inlineCode",{parentName:"p"},"J")," modifier, we added new method ",Object(i.b)("inlineCode",{parentName:"p"},"Detail.usingDuplicateName().group('name')"),". Method\n",Object(i.b)("inlineCode",{parentName:"p"},"usingDuplicateName().group('name')")," only takes a name as an argument (using it with indexes doesn't make any sense),"),Object(i.b)("p",null,"It's almost identical to ",Object(i.b)("inlineCode",{parentName:"p"},"Detail.group('name')")," except, it doesn't have ",Object(i.b)("inlineCode",{parentName:"p"},"index()")," method. It can't have ",Object(i.b)("inlineCode",{parentName:"p"},"index()")," method,\nsince with ",Object(i.b)("inlineCode",{parentName:"p"},"J")," modifier it's impossible to reliably assign an index to a named group, since there are many groups that could\nhave this name. We could add method ",Object(i.b)("inlineCode",{parentName:"p"},"indexes()"),", to get a list of indexes of the groups that share this name, but it's\nimpossible with PHP API."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-php"}),"use \\TRegx\\CleanRegex\\Match\\Details\\Detail;\n\npattern('(?<one>one)? (?<two>two)?', 'J')\n  ->match('one two')\n  ->first(function (Detail $detail) {\n      // These two are identical\n      $detail->group('name')->text(); // always 'one'\n      $detail->group(1)->text();      // always 'one'\n      \n      // These two rely on subject\n      $detail->usingDuplicateName()->group('name')->text(); // either 'one' or 'two'\n  });\n")))}b.isMDXComponent=!0},179:function(e,t,n){"use strict";n.d(t,"a",(function(){return s})),n.d(t,"b",(function(){return d}));var a=n(0),r=n.n(a);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function p(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=r.a.createContext({}),b=function(e){var t=r.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):p(p({},t),e)),n},s=function(e){var t=b(e.components);return r.a.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},m=r.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,o=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),s=b(n),m=a,d=s["".concat(o,".").concat(m)]||s[m]||u[m]||i;return n?r.a.createElement(d,p(p({ref:t},c),{},{components:n})):r.a.createElement(d,p({ref:t},c))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=m;var p={};for(var l in t)hasOwnProperty.call(t,l)&&(p[l]=t[l]);p.originalType=e,p.mdxType="string"==typeof e?e:a,o[1]=p;for(var c=2;c<i;c++)o[c]=n[c];return r.a.createElement.apply(null,o)}return r.a.createElement.apply(null,n)}m.displayName="MDXCreateElement"}}]);