(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{143:function(e,a,t){"use strict";t.r(a),t.d(a,"frontMatter",(function(){return r})),t.d(a,"rightToc",(function(){return c})),t.d(a,"default",(function(){return u}));t(211);var l=t(207),n=t(208),i=t(209);function b(){return(b=Object.assign||function(e){for(var a=1;a<arguments.length;a++){var t=arguments[a];for(var l in t)Object.prototype.hasOwnProperty.call(t,l)&&(e[l]=t[l])}return e}).apply(this,arguments)}const r={id:"is-valid",title:"Validate a pattern"},c=[{value:"Validating",id:"validating",children:[]},{value:"Usable pattern",id:"usable-pattern",children:[]},{value:"Delimited pattern",id:"delimited-pattern",children:[{value:"Exception",id:"exception",children:[]}]}],p={rightToc:c},d="wrapper";function u({components:e,...a}){return Object(l.b)(d,b({},p,a,{components:e,mdxType:"MDXLayout"}),Object(l.b)("h2",{id:"validating"},"Validating"),Object(l.b)("p",null,"You can check whether a pattern is valid and ready to use with ",Object(l.b)("inlineCode",{parentName:"p"},"is()->valid()")," method."),Object(l.b)(n.a,{defaultValue:"T-Regx",values:[{label:"T-Regx",value:"T-Regx"}],mdxType:"Tabs"},Object(l.b)(i.a,{value:"T-Regx",mdxType:"TabItem"},Object(l.b)("pre",null,Object(l.b)("code",b({parentName:"pre"},{className:"language-php"}),"pattern('/I am a valid pattern/')->is()->valid();\n")))),Object(l.b)("div",{className:"output-block"},Object(l.b)("pre",null,Object(l.b)("code",b({parentName:"pre"},{className:"language-php"}),"true\n"))),Object(l.b)("p",null,"Neither ",Object(l.b)("inlineCode",{parentName:"p"},"is()->valid()")," nor ",Object(l.b)("inlineCode",{parentName:"p"},"is()->usable()")," throws an exception or issues any warnings. They only return ",Object(l.b)("inlineCode",{parentName:"p"},"true"),"/",Object(l.b)("inlineCode",{parentName:"p"},"false"),"."),Object(l.b)(n.a,{defaultValue:"T-Regx",values:[{label:"T-Regx",value:"T-Regx"},{label:"PHP",value:"PHP"}],mdxType:"Tabs"},Object(l.b)(i.a,{value:"T-Regx",mdxType:"TabItem"},Object(l.b)("pre",null,Object(l.b)("code",b({parentName:"pre"},{className:"language-php"}),"pattern('I am an (( invalid }} pattern')->is()->valid();\n")))),Object(l.b)("div",{className:"output-block"},Object(l.b)("pre",null,Object(l.b)("code",b({parentName:"pre"},{className:"language-php"}),"false\n"))),Object(l.b)("blockquote",null,Object(l.b)("p",{parentName:"blockquote"},"Patterns validated with ",Object(l.b)("inlineCode",{parentName:"p"},"is()->valid()")," are also valid for methods ",Object(l.b)("inlineCode",{parentName:"p"},"preg_match()"),", ",Object(l.b)("inlineCode",{parentName:"p"},"preg_replace()")," etc.")),Object(l.b)("h2",{id:"usable-pattern"},"Usable pattern"),Object(l.b)("p",null,"A usable pattern is a valid, but not necessarily delimited pattern. In other words:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"is()->valid()")," valid in terms of PCRE ",Object(l.b)("inlineCode",{parentName:"li"},"preg_match()"),", ",Object(l.b)("inlineCode",{parentName:"li"},"preg_replace")," methods (must be delimited)"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"is()->usable()")," valid in terms of ",Object(l.b)("inlineCode",{parentName:"li"},"pattern()")," method (not necessarily delimited, can be ",Object(l.b)("a",b({parentName:"li"},{href:"/docs/delimiters"}),"automatically delimited"),")")),Object(l.b)("p",null,"The pattern doesn't have to be delimited."),Object(l.b)(n.a,{defaultValue:"T-Regx",values:[{label:"T-Regx",value:"T-Regx"}],mdxType:"Tabs"},Object(l.b)(i.a,{value:"T-Regx",mdxType:"TabItem"},Object(l.b)("pre",null,Object(l.b)("code",b({parentName:"pre"},{className:"language-php"}),"pattern('/I am a valid and usable pattern/')->is()->usable();\npattern('I am not delimited, but still a usable pattern')->is()->usable();\n")))),Object(l.b)("div",{className:"output-block"},Object(l.b)("pre",null,Object(l.b)("code",b({parentName:"pre"},{className:"language-php"}),"true\ntrue\n"))),Object(l.b)("p",null,"But it can't be invalid."),Object(l.b)(n.a,{defaultValue:"T-Regx",values:[{label:"T-Regx",value:"T-Regx"}],mdxType:"Tabs"},Object(l.b)(i.a,{value:"T-Regx",mdxType:"TabItem"},Object(l.b)("pre",null,Object(l.b)("code",b({parentName:"pre"},{className:"language-php"}),"pattern('I am (invalid')->is()->usable();\n")))),Object(l.b)("div",{className:"output-block"},Object(l.b)("pre",null,Object(l.b)("code",b({parentName:"pre"},{className:"language-php"}),"false\n"))),Object(l.b)("h2",{id:"delimited-pattern"},"Delimited pattern"),Object(l.b)("p",null,"Method ",Object(l.b)("inlineCode",{parentName:"p"},"is()->delimited()")," is used to verify whether a pattern is delimited or not."),Object(l.b)(n.a,{defaultValue:"T-Regx",values:[{label:"T-Regx",value:"T-Regx"}],mdxType:"Tabs"},Object(l.b)(i.a,{value:"T-Regx",mdxType:"TabItem"},Object(l.b)("pre",null,Object(l.b)("code",b({parentName:"pre"},{className:"language-php"}),"pattern('#I am delimited#')->is()->delimitered();\n")))),Object(l.b)("div",{className:"output-block"},Object(l.b)("pre",null,Object(l.b)("code",b({parentName:"pre"},{className:"language-php"}),"true\n"))),Object(l.b)("hr",null),Object(l.b)(n.a,{defaultValue:"T-Regx",values:[{label:"T-Regx",value:"T-Regx"}],mdxType:"Tabs"},Object(l.b)(i.a,{value:"T-Regx",mdxType:"TabItem"},Object(l.b)("pre",null,Object(l.b)("code",b({parentName:"pre"},{className:"language-php"}),"pattern('I am not delimited')->is()->delimitered();\n")))),Object(l.b)("div",{className:"output-block"},Object(l.b)("pre",null,Object(l.b)("code",b({parentName:"pre"},{className:"language-php"}),"false\n"))),Object(l.b)("blockquote",null,Object(l.b)("p",{parentName:"blockquote"},Object(l.b)("a",b({parentName:"p"},{href:"/docs/delimiters"}),"Automatic delimiters")," use the same implementation as ",Object(l.b)("inlineCode",{parentName:"p"},"is()->delimited()"),", so if a bug is found\nfor ",Object(l.b)("inlineCode",{parentName:"p"},"is()->delimited()")," - it means ",Object(l.b)("inlineCode",{parentName:"p"},"pattern()")," is also prone to that bug.")),Object(l.b)("h3",{id:"exception"},"Exception"),Object(l.b)("p",null,"Keep in mind, however, that an invalid (delimited or not) pattern will\nthrow ",Object(l.b)("inlineCode",{parentName:"p"},"MalformedPatternException")," with ",Object(l.b)("inlineCode",{parentName:"p"},"is()->delimited()"),"."),Object(l.b)("pre",null,Object(l.b)("code",b({parentName:"pre"},{className:"language-php"}),"try {\n    return pattern('I am (invalid')->is()->delimited();\n}\ncatch (MalformedPatternException $exception) {\n\n}\n")))}u.isMDXComponent=!0},208:function(e,a,t){"use strict";var l=t(0),n=t.n(l),i=t(210),b=t.n(i);a.a=function(e){const{block:a,children:t,defaultValue:i,values:r}=e,[c,p]=Object(l.useState)(i);return n.a.createElement("div",null,n.a.createElement("ul",{className:b()("tabs",{"tabs--block":a})},r.map(({value:e,label:a})=>n.a.createElement("li",{className:b()("tab-item",{"tab-item--active":c===e}),key:e,onClick:()=>p(e)},a))),n.a.createElement("div",{className:"margin-vert--md"},l.Children.toArray(t).filter(e=>e.props.value===c)[0]))}},209:function(e,a,t){"use strict";var l=t(0),n=t.n(l);a.a=function(e){return n.a.createElement("div",null,e.children)}}}]);